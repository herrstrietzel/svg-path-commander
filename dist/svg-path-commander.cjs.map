{"version":3,"file":"svg-path-commander.cjs","sources":["../src/options/options.ts","../src/parser/error.ts","../src/parser/paramsCount.ts","../src/parser/finalizeSegment.ts","../src/parser/scanFlag.ts","../src/parser/isDigit.ts","../src/parser/invalidPathValue.ts","../src/parser/scanParam.ts","../src/parser/isSpace.ts","../src/parser/skipSpaces.ts","../src/parser/isPathCommand.ts","../src/parser/isDigitStart.ts","../src/parser/isArcCommand.ts","../src/parser/isMoveCommand.ts","../src/parser/scanSegment.ts","../src/parser/pathParser.ts","../src/util/isPathArray.ts","../src/parser/parsePathString.ts","../src/math/polygonArea.ts","../src/math/distanceSquareRoot.ts","../src/math/polygonLength.ts","../node_modules/.pnpm/@thednp+dommatrix@2.0.8/node_modules/@thednp/dommatrix/dist/dommatrix.mjs","../src/util/isAbsoluteArray.ts","../src/convert/pathToAbsolute.ts","../src/process/normalizeSegment.ts","../src/util/isNormalizedArray.ts","../src/parser/paramsParser.ts","../src/process/normalizePath.ts","../src/math/midPoint.ts","../src/math/lineTools.ts","../src/math/arcTools.ts","../src/math/bezier.ts","../src/math/cubicTools.ts","../src/math/quadTools.ts","../src/util/distanceEpsilon.ts","../src/util/pathFactory.ts","../src/util/getPathBBox.ts","../src/process/fixArc.ts","../src/util/isCurveArray.ts","../src/math/rotateVector.ts","../src/process/arcToCubic.ts","../src/process/quadToCubic.ts","../src/process/lineToCubic.ts","../src/process/segmentToCubic.ts","../src/convert/pathToCurve.ts","../src/util/getPathArea.ts","../src/util/getTotalLength.ts","../src/util/getDrawDirection.ts","../src/util/getPointAtLength.ts","../src/util/getPropertiesAtLength.ts","../src/util/getPropertiesAtPoint.ts","../src/util/getClosestPoint.ts","../src/util/getSegmentOfPoint.ts","../src/util/getSegmentAtLength.ts","../src/util/isPointInStroke.ts","../src/util/isValidPath.ts","../src/util/isRelativeArray.ts","../src/util/shapeParams.ts","../src/util/shapeToPathArray.ts","../src/process/roundPath.ts","../src/convert/pathToString.ts","../src/util/shapeToPath.ts","../src/process/splitPath.ts","../src/process/getSVGMatrix.ts","../src/convert/pathToRelative.ts","../src/process/shortenSegment.ts","../src/process/optimizePath.ts","../src/process/reverseCurve.ts","../src/process/reversePath.ts","../src/process/projection2d.ts","../src/process/replaceArc.ts","../src/process/transformPath.ts","../src/process/splitCubic.ts","../src/index.ts"],"sourcesContent":["import { Options } from '../interface';\n\n/** SVGPathCommander default options */\nconst defaultOptions: Options = {\n  origin: [0, 0, 0],\n  round: 4,\n};\n\nexport default defaultOptions;\n","const error = 'SVGPathCommander Error';\nexport default error;\n","/** Segment params length */\nconst paramsCount = {\n  a: 7,\n  c: 6,\n  h: 1,\n  l: 2,\n  m: 2,\n  r: 4,\n  q: 4,\n  s: 4,\n  t: 2,\n  v: 1,\n  z: 0,\n};\n\nexport default paramsCount;\n","import paramsCount from './paramsCount';\nimport PathParser from './pathParser';\nimport type { PathCommand, PathSegment, RelativeCommand } from '../types';\n\n/**\n * Breaks the parsing of a pathString once a segment is finalized.\n *\n * @param path the `PathParser` instance\n */\nconst finalizeSegment = (path: PathParser) => {\n  let pathCommand = path.pathValue[path.segmentStart] as PathCommand;\n  let LK = pathCommand.toLowerCase() as RelativeCommand;\n  const { data } = path;\n\n  while (data.length >= paramsCount[LK]) {\n    // overloaded `moveTo`\n    // https://github.com/rveciana/svg-path-properties/blob/master/src/parse.ts\n    if (LK === 'm' && data.length > 2) {\n      path.segments.push([pathCommand, ...(data.splice(0, 2) as number[])] as PathSegment);\n      LK = 'l';\n      pathCommand = pathCommand === 'm' ? 'l' : 'L';\n    } else {\n      path.segments.push([pathCommand, ...(data.splice(0, paramsCount[LK]) as number[])] as PathSegment);\n    }\n\n    if (!paramsCount[LK]) {\n      break;\n    }\n  }\n};\nexport default finalizeSegment;\n","import error from './error';\nimport type PathParser from './pathParser';\n\n/**\n * Validates an A (arc-to) specific path command value.\n * Usually a `large-arc-flag` or `sweep-flag`.\n *\n * @param path the `PathParser` instance\n */\nconst scanFlag = (path: PathParser) => {\n  const { index, pathValue } = path;\n  const code = pathValue.charCodeAt(index);\n\n  if (code === 0x30 /* 0 */) {\n    path.param = 0;\n    path.index += 1;\n    return;\n  }\n\n  if (code === 0x31 /* 1 */) {\n    path.param = 1;\n    path.index += 1;\n    return;\n  }\n\n  path.err = `${error}: invalid Arc flag \"${pathValue[index]}\", expecting 0 or 1 at index ${index}`;\n};\n\nexport default scanFlag;\n","import { DigitNumber } from '../types';\n\n/**\n * Checks if a character is a digit.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isDigit = (code: number): code is DigitNumber => {\n  return code >= 48 && code <= 57; // 0..9\n};\nexport default isDigit;\n","const invalidPathValue = 'Invalid path value';\nexport default invalidPathValue;\n","import isDigit from './isDigit';\nimport invalidPathValue from './invalidPathValue';\nimport error from './error';\nimport type PathParser from './pathParser';\n\n/**\n * Validates every character of the path string,\n * every path command, negative numbers or floating point numbers.\n *\n * @param path the `PathParser` instance\n */\nconst scanParam = (path: PathParser) => {\n  const { max, pathValue, index: start } = path;\n  let index = start;\n  let zeroFirst = false;\n  let hasCeiling = false;\n  let hasDecimal = false;\n  let hasDot = false;\n  let ch;\n\n  if (index >= max) {\n    path.err = `${error}: ${invalidPathValue} at index ${index}, \"pathValue\" is missing param`;\n    return;\n  }\n  ch = pathValue.charCodeAt(index);\n\n  if (ch === 0x2b /* + */ || ch === 0x2d /* - */) {\n    index += 1;\n    // ch = (index < max) ? pathValue.charCodeAt(index) : 0;\n    ch = pathValue.charCodeAt(index);\n  }\n\n  // This logic is shamelessly borrowed from Esprima\n  // https://github.com/ariya/esprimas\n  if (!isDigit(ch) && ch !== 0x2e /* . */) {\n    // path.err = 'SvgPath: param should start with 0..9 or `.` (at pos ' + index + ')';\n    path.err = `${error}: ${invalidPathValue} at index ${index}, \"${pathValue[index]}\" is not a number`;\n    return;\n  }\n\n  if (ch !== 0x2e /* . */) {\n    zeroFirst = ch === 0x30 /* 0 */;\n    index += 1;\n\n    ch = pathValue.charCodeAt(index);\n\n    if (zeroFirst && index < max) {\n      // decimal number starts with '0' such as '09' is illegal.\n      if (ch && isDigit(ch)) {\n        // path.err = 'SvgPath: numbers started with `0` such as `09`\n        // are illegal (at pos ' + start + ')';\n        path.err = `${error}: ${invalidPathValue} at index ${start}, \"${pathValue[start]}\" illegal number`;\n        return;\n      }\n    }\n\n    while (index < max && isDigit(pathValue.charCodeAt(index))) {\n      index += 1;\n      hasCeiling = true;\n    }\n\n    ch = pathValue.charCodeAt(index);\n  }\n\n  if (ch === 0x2e /* . */) {\n    hasDot = true;\n    index += 1;\n    while (isDigit(pathValue.charCodeAt(index))) {\n      index += 1;\n      hasDecimal = true;\n    }\n\n    ch = pathValue.charCodeAt(index);\n  }\n\n  if (ch === 0x65 /* e */ || ch === 0x45 /* E */) {\n    if (hasDot && !hasCeiling && !hasDecimal) {\n      path.err = `${error}: ${invalidPathValue} at index ${index}, \"${pathValue[index]}\" invalid float exponent`;\n      return;\n    }\n\n    index += 1;\n\n    ch = pathValue.charCodeAt(index);\n\n    if (ch === 0x2b /* + */ || ch === 0x2d /* - */) {\n      index += 1;\n    }\n    if (index < max && isDigit(pathValue.charCodeAt(index))) {\n      while (index < max && isDigit(pathValue.charCodeAt(index))) {\n        index += 1;\n      }\n    } else {\n      path.err = `${error}: ${invalidPathValue} at index ${index}, \"${pathValue[index]}\" invalid integer exponent`;\n      return;\n    }\n  }\n\n  path.index = index;\n  path.param = +path.pathValue.slice(start, index);\n};\nexport default scanParam;\n","import type { SpaceNumber } from '../types';\n\n/**\n * Checks if the character is a space.\n *\n * @param ch the character to check\n * @returns check result\n */\n\nconst isSpace = (ch: number): ch is SpaceNumber => {\n  const allSpaces = [\n    // Special spaces\n    0x1680, 0x180e, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200a, 0x202f,\n    0x205f, 0x3000, 0xfeff,\n    // Line terminators\n    0x0a, 0x0d, 0x2028, 0x2029,\n    // White spaces\n    0x20, 0x09, 0x0b, 0x0c, 0xa0,\n  ];\n\n  return allSpaces.includes(ch);\n};\nexport default isSpace;\n","import isSpace from './isSpace';\nimport type PathParser from './pathParser';\n\n/**\n * Points the parser to the next character in the\n * path string every time it encounters any kind of\n * space character.\n *\n * @param path the `PathParser` instance\n */\nconst skipSpaces = (path: PathParser) => {\n  const { pathValue, max } = path;\n  while (path.index < max && isSpace(pathValue.charCodeAt(path.index))) {\n    path.index += 1;\n  }\n};\nexport default skipSpaces;\n","import type { PathCommandNumber } from '../types';\n\n/**\n * Checks if the character is a path command.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isPathCommand = (code: number): code is PathCommandNumber => {\n  // eslint-disable-next-line no-bitwise -- Impossible to satisfy\n  switch (code | 0x20) {\n    case 0x6d /* m */:\n    case 0x7a /* z */:\n    case 0x6c /* l */:\n    case 0x68 /* h */:\n    case 0x76 /* v */:\n    case 0x63 /* c */:\n    case 0x73 /* s */:\n    case 0x71 /* q */:\n    case 0x74 /* t */:\n    case 0x61 /* a */:\n      // case 0x72/* r */:\n      return true;\n    default:\n      return false;\n  }\n};\nexport default isPathCommand;\n","import isDigit from './isDigit';\nimport type { DigitNumber } from '../types';\n\n/**\n * Checks if the character is or belongs to a number.\n * [0-9]|+|-|.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isDigitStart = (code: number): code is DigitNumber | 0x2b | 0x2d | 0x2e => {\n  return isDigit(code) /* 0..9 */ || code === 0x2b /* + */ || code === 0x2d /* - */ || code === 0x2e; /* . */\n};\nexport default isDigitStart;\n","/**\n * Checks if the character is an A (arc-to) path command.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isArcCommand = (code: number): code is 0x61 => {\n  // eslint-disable-next-line no-bitwise -- Impossible to satisfy\n  return (code | 0x20) === 0x61;\n};\nexport default isArcCommand;\n","/**\n * Checks if the character is a MoveTo command.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isMoveCommand = (code: number): code is 0x6d | 0x4d => {\n  // eslint-disable-next-line no-bitwise -- Impossible to satisfy\n  switch (code | 0x20) {\n    case 0x6d /* m */:\n    case 0x4d /* M */:\n      return true;\n    default:\n      return false;\n  }\n};\nexport default isMoveCommand;\n","import finalizeSegment from './finalizeSegment';\nimport paramCounts from './paramsCount';\nimport scanFlag from './scanFlag';\nimport scanParam from './scanParam';\nimport skipSpaces from './skipSpaces';\nimport isPathCommand from './isPathCommand';\nimport isDigitStart from './isDigitStart';\nimport isArcCommand from './isArcCommand';\nimport isMoveCommand from './isMoveCommand';\nimport invalidPathValue from './invalidPathValue';\nimport error from './error';\n\nimport type PathParser from './pathParser';\nimport type { PathSegment, RelativeCommand } from '../types';\n\n/**\n * Scans every character in the path string to determine\n * where a segment starts and where it ends.\n *\n * @param path the `PathParser` instance\n */\nconst scanSegment = (path: PathParser) => {\n  const { max, pathValue, index, segments } = path;\n  const cmdCode = pathValue.charCodeAt(index);\n  const reqParams = paramCounts[pathValue[index].toLowerCase() as RelativeCommand];\n\n  path.segmentStart = index;\n\n  // segments always start with a path command\n  if (!isPathCommand(cmdCode)) {\n    path.err = `${error}: ${invalidPathValue} \"${pathValue[index]}\" is not a path command at index ${index}`;\n    return;\n  }\n\n  // after a Z segment, we only expect a MoveTo path command\n  const lastSegment = segments[segments.length - 1] as PathSegment | undefined;\n  if (!isMoveCommand(cmdCode) && lastSegment?.[0]?.toLocaleLowerCase() === 'z') {\n    path.err = `${error}: ${invalidPathValue} \"${pathValue[index]}\" is not a MoveTo path command at index ${index}`;\n    return;\n  }\n\n  path.index += 1;\n  skipSpaces(path);\n\n  path.data = [];\n\n  if (!reqParams) {\n    // Z\n    finalizeSegment(path);\n    return;\n  }\n\n  for (;;) {\n    for (let i = reqParams; i > 0; i -= 1) {\n      if (isArcCommand(cmdCode) && (i === 3 || i === 4)) scanFlag(path);\n      else scanParam(path);\n\n      if (path.err.length) {\n        return;\n      }\n      path.data.push(path.param);\n\n      skipSpaces(path);\n\n      // after ',' param is mandatory\n      if (path.index < max && pathValue.charCodeAt(path.index) === 0x2c /* , */) {\n        path.index += 1;\n        skipSpaces(path);\n      }\n    }\n\n    if (path.index >= path.max) {\n      break;\n    }\n\n    // Stop on next segment\n    if (!isDigitStart(pathValue.charCodeAt(path.index))) {\n      break;\n    }\n  }\n\n  finalizeSegment(path);\n};\nexport default scanSegment;\n","import type { PathArray, PathSegment } from '../types';\n\n/**\n * The `PathParser` is used by the `parsePathString` static method\n * to generate a `pathArray`.\n *\n * @param pathString\n */\nexport default class PathParser {\n  declare segments: PathArray | PathSegment[];\n  declare pathValue: string;\n  declare max: number;\n  declare index: number;\n  declare param: number;\n  declare segmentStart: number;\n  declare data: any[];\n  declare err: string;\n\n  constructor(pathString: string) {\n    this.segments = [];\n    this.pathValue = pathString;\n    this.max = pathString.length;\n    this.index = 0;\n    this.param = 0.0;\n    this.segmentStart = 0;\n    this.data = [];\n    this.err = '';\n  }\n}\n","import type { PathArray, PathSegment, RelativeCommand } from '../types';\nimport paramsCount from '../parser/paramsCount';\n\n/**\n * Iterates an array to check if it's an actual `pathArray`.\n *\n * @param path the `pathArray` to be checked\n * @returns iteration result\n */\nconst isPathArray = (path: unknown): path is PathArray => {\n  return (\n    Array.isArray(path) &&\n    path.every((seg: PathSegment) => {\n      const lk = seg[0].toLowerCase() as RelativeCommand;\n      return (\n        paramsCount[lk] === seg.length - 1 &&\n        'achlmqstvz'.includes(lk) &&\n        (seg.slice(1) as unknown[]).every(Number.isFinite)\n      );\n    }) &&\n    path.length > 0\n  );\n};\nexport default isPathArray;\n","import scanSegment from './scanSegment';\nimport skipSpaces from './skipSpaces';\nimport PathParser from './pathParser';\nimport isPathArray from '../util/isPathArray';\nimport type { PathArray } from '../types';\n\n/**\n * Parses a path string value and returns an array\n * of segments we like to call `pathArray`.\n *\n * @param pathInput the string to be parsed\n * @returns the resulted `pathArray` or error string\n */\nconst parsePathString = (pathInput: string | PathArray): PathArray => {\n  if (isPathArray(pathInput)) {\n    return pathInput.slice(0) as PathArray;\n  }\n\n  const path = new PathParser(pathInput);\n\n  skipSpaces(path);\n\n  while (path.index < path.max && !path.err.length) {\n    scanSegment(path);\n  }\n\n  if (path.err && path.err.length) {\n    throw TypeError(path.err);\n  }\n\n  return path.segments as PathArray;\n};\n\nexport default parsePathString;\n","/**\n * d3-polygon-area\n * https://github.com/d3/d3-polygon\n *\n * Returns the area of a polygon.\n *\n * @param polygon an array of coordinates\n * @returns the polygon area\n */\nconst polygonArea = (polygon: [number, number][]): number => {\n  const n = polygon.length;\n  let i = -1;\n  let a;\n  let b = polygon[n - 1];\n  let area = 0;\n\n  /* eslint-disable-next-line */\n  while (++i < n) {\n    a = b;\n    b = polygon[i];\n    area += a[1] * b[0] - a[0] * b[1];\n  }\n\n  return area / 2;\n};\n\nexport default polygonArea;\n","/**\n * Returns the square root of the distance\n * between two given points.\n *\n * @param a the first point coordinates\n * @param b the second point coordinates\n * @returns the distance value\n */\nconst distanceSquareRoot = (a: [number, number], b: [number, number]): number => {\n  return Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]));\n};\n\nexport default distanceSquareRoot;\n","import distanceSquareRoot from './distanceSquareRoot';\n\n/**\n * d3-polygon-length\n * https://github.com/d3/d3-polygon\n *\n * Returns the perimeter of a polygon.\n *\n * @param polygon an array of coordinates\n * @returns {number} the polygon length\n */\nconst polygonLength = (polygon: [number, number][]): number => {\n  return polygon.reduce((length, point, i) => {\n    if (i) {\n      return length + distanceSquareRoot(polygon[i - 1], point);\n    }\n    return 0;\n  }, 0);\n};\n\nexport default polygonLength;\n","var Z = Object.defineProperty;\nvar z = (s, t, e) => t in s ? Z(s, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[t] = e;\nvar p = (s, t, e) => z(s, typeof t != \"symbol\" ? t + \"\" : t, e);\nconst $ = {\n  a: 1,\n  b: 0,\n  c: 0,\n  d: 1,\n  e: 0,\n  f: 0,\n  m11: 1,\n  m12: 0,\n  m13: 0,\n  m14: 0,\n  m21: 0,\n  m22: 1,\n  m23: 0,\n  m24: 0,\n  m31: 0,\n  m32: 0,\n  m33: 1,\n  m34: 0,\n  m41: 0,\n  m42: 0,\n  m43: 0,\n  m44: 1,\n  is2D: !0,\n  isIdentity: !0\n}, E = (s) => (s instanceof Float64Array || s instanceof Float32Array || Array.isArray(s) && s.every((t) => typeof t == \"number\")) && [6, 16].some((t) => s.length === t), P = (s) => s instanceof DOMMatrix || s instanceof y || typeof s == \"object\" && Object.keys($).every((t) => s && t in s), g = (s) => {\n  const t = new y(), e = Array.from(s);\n  if (!E(e))\n    throw TypeError(`CSSMatrix: \"${e.join(\",\")}\" must be an array with 6/16 numbers.`);\n  // istanbul ignore else @preserve\n  if (e.length === 16) {\n    const [n, i, r, a, l, m, h, c, u, f, w, o, d, A, M, b] = e;\n    t.m11 = n, t.a = n, t.m21 = l, t.c = l, t.m31 = u, t.m41 = d, t.e = d, t.m12 = i, t.b = i, t.m22 = m, t.d = m, t.m32 = f, t.m42 = A, t.f = A, t.m13 = r, t.m23 = h, t.m33 = w, t.m43 = M, t.m14 = a, t.m24 = c, t.m34 = o, t.m44 = b;\n  } else if (e.length === 6) {\n    const [n, i, r, a, l, m] = e;\n    t.m11 = n, t.a = n, t.m12 = i, t.b = i, t.m21 = r, t.c = r, t.m22 = a, t.d = a, t.m41 = l, t.e = l, t.m42 = m, t.f = m;\n  }\n  return t;\n}, X = (s) => {\n  if (P(s))\n    return g([\n      s.m11,\n      s.m12,\n      s.m13,\n      s.m14,\n      s.m21,\n      s.m22,\n      s.m23,\n      s.m24,\n      s.m31,\n      s.m32,\n      s.m33,\n      s.m34,\n      s.m41,\n      s.m42,\n      s.m43,\n      s.m44\n    ]);\n  throw TypeError(`CSSMatrix: \"${JSON.stringify(s)}\" is not a DOMMatrix / CSSMatrix / JSON compatible object.`);\n}, O = (s) => {\n  if (typeof s != \"string\")\n    throw TypeError(`CSSMatrix: \"${JSON.stringify(s)}\" is not a string.`);\n  const t = String(s).replace(/\\s/g, \"\");\n  let e = new y();\n  const n = `CSSMatrix: invalid transform string \"${s}\"`;\n  return t.split(\")\").filter((i) => i).forEach((i) => {\n    const [r, a] = i.split(\"(\");\n    if (!a) throw TypeError(n);\n    const l = a.split(\",\").map((o) => o.includes(\"rad\") ? parseFloat(o) * (180 / Math.PI) : parseFloat(o)), [m, h, c, u] = l, f = [m, h, c], w = [m, h, c, u];\n    if (r === \"perspective\" && m && [h, c].every((o) => o === void 0))\n      e.m34 = -1 / m;\n    else if (r.includes(\"matrix\") && [6, 16].includes(l.length) && l.every((o) => !Number.isNaN(+o))) {\n      const o = l.map((d) => Math.abs(d) < 1e-6 ? 0 : d);\n      e = e.multiply(g(o));\n    } else if (r === \"translate3d\" && f.every((o) => !Number.isNaN(+o)))\n      e = e.translate(m, h, c);\n    else if (r === \"translate\" && m && c === void 0)\n      e = e.translate(m, h || 0, 0);\n    else if (r === \"rotate3d\" && w.every((o) => !Number.isNaN(+o)) && u)\n      e = e.rotateAxisAngle(m, h, c, u);\n    else if (r === \"rotate\" && m && [h, c].every((o) => o === void 0))\n      e = e.rotate(0, 0, m);\n    else if (r === \"scale3d\" && f.every((o) => !Number.isNaN(+o)) && f.some((o) => o !== 1))\n      e = e.scale(m, h, c);\n    else if (r === \"scale\" && !Number.isNaN(m) && m !== 1 && c === void 0) {\n      const d = Number.isNaN(+h) ? m : h;\n      e = e.scale(m, d, 1);\n    } else if (r === \"skew\" && (m || !Number.isNaN(m) && h) && c === void 0)\n      e = e.skew(m, h || 0);\n    else if ([\"translate\", \"rotate\", \"scale\", \"skew\"].some((o) => r.includes(o)) && /[XYZ]/.test(r) && m && [h, c].every((o) => o === void 0))\n      if (r === \"skewX\" || r === \"skewY\")\n        e = e[r](m);\n      else {\n        const o = r.replace(/[XYZ]/, \"\"), d = r.replace(o, \"\"), A = [\"X\", \"Y\", \"Z\"].indexOf(d), M = o === \"scale\" ? 1 : 0, b = [A === 0 ? m : M, A === 1 ? m : M, A === 2 ? m : M];\n        e = e[o](...b);\n      }\n    else\n      throw TypeError(n);\n  }), e;\n}, x = (s, t) => t ? [s.a, s.b, s.c, s.d, s.e, s.f] : [\n  s.m11,\n  s.m12,\n  s.m13,\n  s.m14,\n  s.m21,\n  s.m22,\n  s.m23,\n  s.m24,\n  s.m31,\n  s.m32,\n  s.m33,\n  s.m34,\n  s.m41,\n  s.m42,\n  s.m43,\n  s.m44\n], Y = (s, t, e) => {\n  const n = new y();\n  return n.m41 = s, n.e = s, n.m42 = t, n.f = t, n.m43 = e, n;\n}, F = (s, t, e) => {\n  const n = new y(), i = Math.PI / 180, r = s * i, a = t * i, l = e * i, m = Math.cos(r), h = -Math.sin(r), c = Math.cos(a), u = -Math.sin(a), f = Math.cos(l), w = -Math.sin(l), o = c * f, d = -c * w;\n  n.m11 = o, n.a = o, n.m12 = d, n.b = d, n.m13 = u;\n  const A = h * u * f + m * w;\n  n.m21 = A, n.c = A;\n  const M = m * f - h * u * w;\n  return n.m22 = M, n.d = M, n.m23 = -h * c, n.m31 = h * w - m * u * f, n.m32 = h * f + m * u * w, n.m33 = m * c, n;\n}, T = (s, t, e, n) => {\n  const i = new y(), r = Math.sqrt(s * s + t * t + e * e);\n  if (r === 0)\n    return i;\n  const a = s / r, l = t / r, m = e / r, h = n * (Math.PI / 360), c = Math.sin(h), u = Math.cos(h), f = c * c, w = a * a, o = l * l, d = m * m, A = 1 - 2 * (o + d) * f;\n  i.m11 = A, i.a = A;\n  const M = 2 * (a * l * f + m * c * u);\n  i.m12 = M, i.b = M, i.m13 = 2 * (a * m * f - l * c * u);\n  const b = 2 * (l * a * f - m * c * u);\n  i.m21 = b, i.c = b;\n  const k = 1 - 2 * (d + w) * f;\n  return i.m22 = k, i.d = k, i.m23 = 2 * (l * m * f + a * c * u), i.m31 = 2 * (m * a * f + l * c * u), i.m32 = 2 * (m * l * f - a * c * u), i.m33 = 1 - 2 * (w + o) * f, i;\n}, I = (s, t, e) => {\n  const n = new y();\n  return n.m11 = s, n.a = s, n.m22 = t, n.d = t, n.m33 = e, n;\n}, v = (s, t) => {\n  const e = new y();\n  if (s) {\n    const n = s * Math.PI / 180, i = Math.tan(n);\n    e.m21 = i, e.c = i;\n  }\n  if (t) {\n    const n = t * Math.PI / 180, i = Math.tan(n);\n    e.m12 = i, e.b = i;\n  }\n  return e;\n}, R = (s) => v(s, 0), D = (s) => v(0, s), N = (s, t) => {\n  const e = t.m11 * s.m11 + t.m12 * s.m21 + t.m13 * s.m31 + t.m14 * s.m41, n = t.m11 * s.m12 + t.m12 * s.m22 + t.m13 * s.m32 + t.m14 * s.m42, i = t.m11 * s.m13 + t.m12 * s.m23 + t.m13 * s.m33 + t.m14 * s.m43, r = t.m11 * s.m14 + t.m12 * s.m24 + t.m13 * s.m34 + t.m14 * s.m44, a = t.m21 * s.m11 + t.m22 * s.m21 + t.m23 * s.m31 + t.m24 * s.m41, l = t.m21 * s.m12 + t.m22 * s.m22 + t.m23 * s.m32 + t.m24 * s.m42, m = t.m21 * s.m13 + t.m22 * s.m23 + t.m23 * s.m33 + t.m24 * s.m43, h = t.m21 * s.m14 + t.m22 * s.m24 + t.m23 * s.m34 + t.m24 * s.m44, c = t.m31 * s.m11 + t.m32 * s.m21 + t.m33 * s.m31 + t.m34 * s.m41, u = t.m31 * s.m12 + t.m32 * s.m22 + t.m33 * s.m32 + t.m34 * s.m42, f = t.m31 * s.m13 + t.m32 * s.m23 + t.m33 * s.m33 + t.m34 * s.m43, w = t.m31 * s.m14 + t.m32 * s.m24 + t.m33 * s.m34 + t.m34 * s.m44, o = t.m41 * s.m11 + t.m42 * s.m21 + t.m43 * s.m31 + t.m44 * s.m41, d = t.m41 * s.m12 + t.m42 * s.m22 + t.m43 * s.m32 + t.m44 * s.m42, A = t.m41 * s.m13 + t.m42 * s.m23 + t.m43 * s.m33 + t.m44 * s.m43, M = t.m41 * s.m14 + t.m42 * s.m24 + t.m43 * s.m34 + t.m44 * s.m44;\n  return g([e, n, i, r, a, l, m, h, c, u, f, w, o, d, A, M]);\n};\nclass y {\n  /**\n   * @constructor\n   * @param init accepts all parameter configurations:\n   * * valid CSS transform string,\n   * * CSSMatrix/DOMMatrix instance,\n   * * a 6/16 elements *Array*.\n   */\n  constructor(t) {\n    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.e = 0, this.f = 0, this.m11 = 1, this.m12 = 0, this.m13 = 0, this.m14 = 0, this.m21 = 0, this.m22 = 1, this.m23 = 0, this.m24 = 0, this.m31 = 0, this.m32 = 0, this.m33 = 1, this.m34 = 0, this.m41 = 0, this.m42 = 0, this.m43 = 0, this.m44 = 1, t ? this.setMatrixValue(t) : this;\n  }\n  /**\n   * A `Boolean` whose value is `true` if the matrix is the identity matrix. The identity\n   * matrix is one in which every value is 0 except those on the main diagonal from top-left\n   * to bottom-right corner (in other words, where the offsets in each direction are equal).\n   *\n   * @return the current property value\n   */\n  get isIdentity() {\n    return this.m11 === 1 && this.m12 === 0 && this.m13 === 0 && this.m14 === 0 && this.m21 === 0 && this.m22 === 1 && this.m23 === 0 && this.m24 === 0 && this.m31 === 0 && this.m32 === 0 && this.m33 === 1 && this.m34 === 0 && this.m41 === 0 && this.m42 === 0 && this.m43 === 0 && this.m44 === 1;\n  }\n  /**\n   * A `Boolean` flag whose value is `true` if the matrix was initialized as a 2D matrix\n   * and `false` if the matrix is 3D.\n   *\n   * @return the current property value\n   */\n  get is2D() {\n    return this.m31 === 0 && this.m32 === 0 && this.m33 === 1 && this.m34 === 0 && this.m43 === 0 && this.m44 === 1;\n  }\n  /**\n   * The `setMatrixValue` method replaces the existing matrix with one computed\n   * in the browser. EG: `matrix(1,0.25,-0.25,1,0,0)`\n   *\n   * The method accepts any *Array* values, the result of\n   * `DOMMatrix` instance method `toFloat64Array()` / `toFloat32Array()` calls\n   * or `CSSMatrix` instance method `toArray()`.\n   *\n   * This method expects valid *matrix()* / *matrix3d()* string values, as well\n   * as other transform functions like *translateX(10px)*.\n   *\n   * @param source\n   * @return the matrix instance\n   */\n  setMatrixValue(t) {\n    return typeof t == \"string\" && t.length && t !== \"none\" ? O(t) : Array.isArray(t) || t instanceof Float64Array || t instanceof Float32Array ? g(t) : typeof t == \"object\" ? X(t) : this;\n  }\n  /**\n   * Returns a *Float32Array* containing elements which comprise the matrix.\n   * The method can return either the 16 elements or the 6 elements\n   * depending on the value of the `is2D` parameter.\n   *\n   * @param is2D *Array* representation of the matrix\n   * @return an *Array* representation of the matrix\n   */\n  toFloat32Array(t) {\n    return Float32Array.from(x(this, t));\n  }\n  /**\n   * Returns a *Float64Array* containing elements which comprise the matrix.\n   * The method can return either the 16 elements or the 6 elements\n   * depending on the value of the `is2D` parameter.\n   *\n   * @param is2D *Array* representation of the matrix\n   * @return an *Array* representation of the matrix\n   */\n  toFloat64Array(t) {\n    return Float64Array.from(x(this, t));\n  }\n  /**\n   * Creates and returns a string representation of the matrix in `CSS` matrix syntax,\n   * using the appropriate `CSS` matrix notation.\n   *\n   * matrix3d *matrix3d(m11, m12, m13, m14, m21, ...)*\n   * matrix *matrix(a, b, c, d, e, f)*\n   *\n   * @return a string representation of the matrix\n   */\n  toString() {\n    const { is2D: t } = this, e = this.toFloat64Array(t).join(\", \");\n    return `${t ? \"matrix\" : \"matrix3d\"}(${e})`;\n  }\n  /**\n   * Returns a JSON representation of the `CSSMatrix` instance, a standard *Object*\n   * that includes `{a,b,c,d,e,f}` and `{m11,m12,m13,..m44}` properties as well\n   * as the `is2D` & `isIdentity` properties.\n   *\n   * The result can also be used as a second parameter for the `fromMatrix` static method\n   * to load values into another matrix instance.\n   *\n   * @return an *Object* with all matrix values.\n   */\n  toJSON() {\n    const { is2D: t, isIdentity: e } = this;\n    return { ...this, is2D: t, isIdentity: e };\n  }\n  /**\n   * The Multiply method returns a new CSSMatrix which is the result of this\n   * matrix multiplied by the passed matrix, with the passed matrix to the right.\n   * This matrix is not modified.\n   *\n   * @param m2 CSSMatrix\n   * @return The resulted matrix.\n   */\n  multiply(t) {\n    return N(this, t);\n  }\n  /**\n   * The translate method returns a new matrix which is this matrix post\n   * multiplied by a translation matrix containing the passed values. If the z\n   * component is undefined, a 0 value is used in its place. This matrix is not\n   * modified.\n   *\n   * @param x X component of the translation value.\n   * @param y Y component of the translation value.\n   * @param z Z component of the translation value.\n   * @return The resulted matrix\n   */\n  translate(t, e, n) {\n    const i = t;\n    let r = e, a = n;\n    return typeof r > \"u\" && (r = 0), typeof a > \"u\" && (a = 0), N(this, Y(i, r, a));\n  }\n  /**\n   * The scale method returns a new matrix which is this matrix post multiplied by\n   * a scale matrix containing the passed values. If the z component is undefined,\n   * a 1 value is used in its place. If the y component is undefined, the x\n   * component value is used in its place. This matrix is not modified.\n   *\n   * @param x The X component of the scale value.\n   * @param y The Y component of the scale value.\n   * @param z The Z component of the scale value.\n   * @return The resulted matrix\n   */\n  scale(t, e, n) {\n    const i = t;\n    let r = e, a = n;\n    return typeof r > \"u\" && (r = t), typeof a > \"u\" && (a = 1), N(this, I(i, r, a));\n  }\n  /**\n   * The rotate method returns a new matrix which is this matrix post multiplied\n   * by each of 3 rotation matrices about the major axes, first X, then Y, then Z.\n   * If the y and z components are undefined, the x value is used to rotate the\n   * object about the z axis, as though the vector (0,0,x) were passed. All\n   * rotation values are in degrees. This matrix is not modified.\n   *\n   * @param rx The X component of the rotation, or Z if Y and Z are null.\n   * @param ry The (optional) Y component of the rotation value.\n   * @param rz The (optional) Z component of the rotation value.\n   * @return The resulted matrix\n   */\n  rotate(t, e, n) {\n    let i = t, r = e || 0, a = n || 0;\n    return typeof t == \"number\" && typeof e > \"u\" && typeof n > \"u\" && (a = i, i = 0, r = 0), N(this, F(i, r, a));\n  }\n  /**\n   * The rotateAxisAngle method returns a new matrix which is this matrix post\n   * multiplied by a rotation matrix with the given axis and `angle`. The right-hand\n   * rule is used to determine the direction of rotation. All rotation values are\n   * in degrees. This matrix is not modified.\n   *\n   * @param x The X component of the axis vector.\n   * @param y The Y component of the axis vector.\n   * @param z The Z component of the axis vector.\n   * @param angle The angle of rotation about the axis vector, in degrees.\n   * @return The resulted matrix\n   */\n  rotateAxisAngle(t, e, n, i) {\n    if ([t, e, n, i].some((r) => Number.isNaN(+r)))\n      throw new TypeError(\"CSSMatrix: expecting 4 values\");\n    return N(this, T(t, e, n, i));\n  }\n  /**\n   * Specifies a skew transformation along the `x-axis` by the given angle.\n   * This matrix is not modified.\n   *\n   * @param angle The angle amount in degrees to skew.\n   * @return The resulted matrix\n   */\n  skewX(t) {\n    return N(this, R(t));\n  }\n  /**\n   * Specifies a skew transformation along the `y-axis` by the given angle.\n   * This matrix is not modified.\n   *\n   * @param angle The angle amount in degrees to skew.\n   * @return The resulted matrix\n   */\n  skewY(t) {\n    return N(this, D(t));\n  }\n  /**\n   * Specifies a skew transformation along both the `x-axis` and `y-axis`.\n   * This matrix is not modified.\n   *\n   * @param angleX The X-angle amount in degrees to skew.\n   * @param angleY The angle amount in degrees to skew.\n   * @return The resulted matrix\n   */\n  skew(t, e) {\n    return N(this, v(t, e));\n  }\n  /**\n   * Transforms a specified vector using the matrix, returning a new\n   * {x,y,z,w} Tuple *Object* comprising the transformed vector.\n   * Neither the matrix nor the original vector are altered.\n   *\n   * The method is equivalent with `transformPoint()` method\n   * of the `DOMMatrix` constructor.\n   *\n   * @param t Tuple with `{x,y,z,w}` components\n   * @return the resulting Tuple\n   */\n  transformPoint(t) {\n    const e = this.m11 * t.x + this.m21 * t.y + this.m31 * t.z + this.m41 * t.w, n = this.m12 * t.x + this.m22 * t.y + this.m32 * t.z + this.m42 * t.w, i = this.m13 * t.x + this.m23 * t.y + this.m33 * t.z + this.m43 * t.w, r = this.m14 * t.x + this.m24 * t.y + this.m34 * t.z + this.m44 * t.w;\n    return t instanceof DOMPoint ? new DOMPoint(e, n, i, r) : {\n      x: e,\n      y: n,\n      z: i,\n      w: r\n    };\n  }\n}\np(y, \"Translate\", Y), p(y, \"Rotate\", F), p(y, \"RotateAxisAngle\", T), p(y, \"Scale\", I), p(y, \"SkewX\", R), p(y, \"SkewY\", D), p(y, \"Skew\", v), p(y, \"Multiply\", N), p(y, \"fromArray\", g), p(y, \"fromMatrix\", X), p(y, \"fromString\", O), p(y, \"toArray\", x), p(y, \"isCompatibleArray\", E), p(y, \"isCompatibleObject\", P);\nexport {\n  y as default\n};\n//# sourceMappingURL=dommatrix.mjs.map\n","import type { AbsoluteArray } from '../types';\nimport isPathArray from './isPathArray';\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with all absolute values.\n *\n * @param path the `pathArray` to be checked\n * @returns iteration result\n */\nconst isAbsoluteArray = (path: unknown): path is AbsoluteArray => {\n  return (\n    isPathArray(path) &&\n    // `isPathArray` also checks if it's `Array`\n    path.every(([x]) => x === x.toUpperCase())\n  );\n};\nexport default isAbsoluteArray;\n","import parsePathString from '../parser/parsePathString';\nimport isAbsoluteArray from '../util/isAbsoluteArray';\nimport type {\n  PathArray,\n  AbsoluteArray,\n  AbsoluteCommand,\n  AbsoluteSegment,\n  VSegment,\n  HSegment,\n  QSegment,\n  TSegment,\n  ASegment,\n  SSegment,\n  CSegment,\n  MSegment,\n} from '../types';\n\n/**\n * Parses a path string value or object and returns an array\n * of segments, all converted to absolute values.\n *\n * @param pathInput the path string | object\n * @returns the resulted `pathArray` with absolute values\n */\nconst pathToAbsolute = (pathInput: string | PathArray): AbsoluteArray => {\n  /* istanbul ignore else */\n  if (isAbsoluteArray(pathInput)) {\n    return pathInput.slice(0) as AbsoluteArray;\n  }\n\n  const path = parsePathString(pathInput);\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n\n  // the `absoluteSegment[]` is for sure an `absolutePath`\n  return path.map(segment => {\n    const values = segment.slice(1).map(Number);\n    const [pathCommand] = segment;\n    const absCommand = pathCommand.toUpperCase() as AbsoluteCommand;\n\n    if (pathCommand === 'M') {\n      [x, y] = values;\n      mx = x;\n      my = y;\n      return ['M', x, y] as MSegment;\n    }\n\n    let absoluteSegment = [] as unknown as AbsoluteSegment;\n\n    if (pathCommand !== absCommand) {\n      if (absCommand === 'A') {\n        absoluteSegment = [\n          absCommand,\n          values[0],\n          values[1],\n          values[2],\n          values[3],\n          values[4],\n          values[5] + x,\n          values[6] + y,\n        ] as ASegment;\n      } else if (absCommand === 'V') {\n        absoluteSegment = [absCommand, values[0] + y] as VSegment;\n      } else if (absCommand === 'H') {\n        absoluteSegment = [absCommand, values[0] + x] as HSegment;\n      } else {\n        // use brakets for `eslint: no-case-declaration`\n        // https://stackoverflow.com/a/50753272/803358\n        const absValues = values.map((n, j) => n + (j % 2 ? y : x));\n        // for n, l, c, s, q, t\n        absoluteSegment = [absCommand, ...absValues] as QSegment | TSegment | SSegment | CSegment;\n      }\n    } else {\n      absoluteSegment = [absCommand, ...values] as typeof segment;\n    }\n\n    // const segLength = absoluteSegment.length;\n    if (absCommand === 'Z') {\n      x = mx;\n      y = my;\n    } else if (absCommand === 'H') {\n      [, x] = absoluteSegment as HSegment;\n    } else if (absCommand === 'V') {\n      [, y] = absoluteSegment as VSegment;\n    } else {\n      // x = absoluteSegment[segLength - 2];\n      // y = absoluteSegment[segLength - 1];\n      [x, y] = absoluteSegment.slice(-2) as [number, number];\n\n      if (absCommand === 'M') {\n        mx = x;\n        my = y;\n      }\n    }\n\n    return absoluteSegment;\n  }) as AbsoluteArray;\n};\nexport default pathToAbsolute;\n","import type { ParserParams } from '../interface';\nimport type { NormalSegment, PathSegment } from '../types';\n\n/**\n * Normalizes a single segment of a `pathArray` object.\n *\n * @param segment the segment object\n * @param params the coordinates of the previous segment\n * @returns the normalized segment\n */\nconst normalizeSegment = (segment: PathSegment, params: ParserParams): NormalSegment => {\n  const [pathCommand] = segment;\n  const { x1: px1, y1: py1, x2: px2, y2: py2 } = params;\n  const values = segment.slice(1).map(Number);\n  let result = segment;\n\n  if (!'TQ'.includes(pathCommand)) {\n    // optional but good to be cautious\n    params.qx = null;\n    params.qy = null;\n  }\n\n  if (pathCommand === 'H') {\n    result = ['L', segment[1], py1];\n  } else if (pathCommand === 'V') {\n    result = ['L', px1, segment[1]];\n  } else if (pathCommand === 'S') {\n    const x1 = px1 * 2 - px2;\n    const y1 = py1 * 2 - py2;\n    params.x1 = x1;\n    params.y1 = y1;\n    result = ['C', x1, y1, ...(values as [number, number, number, number])];\n  } else if (pathCommand === 'T') {\n    const qx = px1 * 2 - (params.qx ? params.qx : /* istanbul ignore next */ 0);\n    const qy = py1 * 2 - (params.qy ? params.qy : /* istanbul ignore next */ 0);\n    params.qx = qx;\n    params.qy = qy;\n    result = ['Q', qx, qy, ...(values as [number, number])];\n  } else if (pathCommand === 'Q') {\n    const [nqx, nqy] = values as [number, number];\n    params.qx = nqx;\n    params.qy = nqy;\n  }\n\n  return result as NormalSegment;\n};\nexport default normalizeSegment;\n","import type { NormalArray } from '../types';\nimport isAbsoluteArray from './isAbsoluteArray';\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with all segments are in non-shorthand notation\n * with absolute values.\n *\n * @param {string | SVGPath.pathArray} path the `pathArray` to be checked\n * @returns {boolean} iteration result\n */\nconst isNormalizedArray = (path: unknown): path is NormalArray => {\n  // `isAbsoluteArray` also checks if it's `Array`\n  return isAbsoluteArray(path) && path.every(([pc]) => 'ACLMQZ'.includes(pc));\n};\nexport default isNormalizedArray;\n","import type { ParserParams } from '../interface';\n\nconst paramsParser: ParserParams = {\n  x1: 0,\n  y1: 0,\n  x2: 0,\n  y2: 0,\n  x: 0,\n  y: 0,\n  qx: null,\n  qy: null,\n};\n\nexport default paramsParser;\n","import pathToAbsolute from '../convert/pathToAbsolute';\nimport normalizeSegment from './normalizeSegment';\nimport isNormalizedArray from '../util/isNormalizedArray';\nimport paramsParser from '../parser/paramsParser';\nimport type { NormalArray, PathArray } from '../types';\n\n/**\n * Normalizes a `path` object for further processing:\n * * convert segments to absolute values\n * * convert shorthand path commands to their non-shorthand notation\n *\n * @param pathInput the string to be parsed or 'pathArray'\n * @returns the normalized `pathArray`\n */\nconst normalizePath = (pathInput: string | PathArray): NormalArray => {\n  if (isNormalizedArray(pathInput)) {\n    return pathInput.slice(0) as NormalArray;\n  }\n\n  const path = pathToAbsolute(pathInput);\n  const params = { ...paramsParser };\n  const allPathCommands = [];\n  const ii = path.length;\n  let pathCommand = '';\n\n  for (let i = 0; i < ii; i += 1) {\n    [pathCommand] = path[i];\n\n    // Save current path command\n    allPathCommands[i] = pathCommand;\n    path[i] = normalizeSegment(path[i], params);\n\n    const segment = path[i];\n    const seglen = segment.length;\n\n    params.x1 = +segment[seglen - 2];\n    params.y1 = +segment[seglen - 1];\n    params.x2 = +segment[seglen - 4] || params.x1;\n    params.y2 = +segment[seglen - 3] || params.y1;\n  }\n\n  return path as NormalArray;\n};\nexport default normalizePath;\n","/**\n * Returns the coordinates of a specified distance\n * ratio between two points.\n *\n * @param a the first point coordinates\n * @param b the second point coordinates\n * @param t the ratio\n * @returns the midpoint coordinates\n */\nconst midPoint = (a: [number, number], b: [number, number], t: number): [number, number] => {\n  const [ax, ay] = a;\n  const [bx, by] = b;\n  return [ax + (bx - ax) * t, ay + (by - ay) * t];\n};\n\nexport default midPoint;\n","import midPoint from './midPoint';\nimport distanceSquareRoot from './distanceSquareRoot';\n\n/**\n * Returns properties for line segments (MoveTo, LineTo).\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param distance the distance to point\n * @returns the segment length, point at length and the bounding box\n */\nconst getSegmentProperties = (x1: number, y1: number, x2: number, y2: number, distance?: number) => {\n  const { min, max } = Math;\n  let point = { x: 0, y: 0 };\n  const length = () => distanceSquareRoot([x1, y1], [x2, y2]);\n\n  /* istanbul ignore else @preserve */\n  if (typeof distance === 'number') {\n    const currentLength = length();\n    if (distance <= 0) {\n      point = { x: x1, y: y1 };\n    } else if (distance >= currentLength) {\n      point = { x: x2, y: y2 };\n    } else {\n      const [x, y] = midPoint([x1, y1], [x2, y2], distance / currentLength);\n      point = { x, y };\n    }\n  }\n\n  return {\n    point,\n    get length() {\n      return length();\n    },\n    get bbox() {\n      return {\n        min: {\n          x: min(x1, x2),\n          y: min(y1, y2),\n        },\n        max: {\n          x: max(x1, x2),\n          y: max(y1, y2),\n        },\n      };\n    },\n  };\n};\n\nexport default getSegmentProperties;\n","import { default as getLineSegmentProperties } from './lineTools';\nimport type { Point } from '../types';\n\n/**\n * Returns the Arc segment length.\n * @param rx radius along X axis\n * @param ry radius along Y axis\n * @param theta the angle in radians\n * @returns the arc length\n */\nconst ellipticalArcLength = (rx: number, ry: number, theta: number) => {\n  const halfTheta = theta / 2;\n  const sinHalfTheta = Math.sin(halfTheta);\n  const cosHalfTheta = Math.cos(halfTheta);\n  const term1 = rx ** 2 * sinHalfTheta ** 2;\n  const term2 = ry ** 2 * cosHalfTheta ** 2;\n  const arcLength = Math.sqrt(term1 + term2) * theta;\n  return Math.abs(arcLength);\n};\n\n/**\n * Returns the most extreme points in an Arc segment.\n * @param x Center X coordinate of the ellipse arc\n * @param y Center Y coordinate of the ellipse arc\n * @param rx Radius on the X axis of the ellipse\n * @param ry Radius on the Y axis of the ellipse\n * @param rotation The ellipse rotation angle in radians\n * @param startAngle The ellipse start angle in radians\n * @param endAngle The ellipse end angle in radians\n * @see https://stackoverflow.com/questions/87734/how-do-you-calculate-the-axis-aligned-bounding-box-of-an-ellipse\n */\nconst minmax = (\n  x: number,\n  y: number,\n  rx: number,\n  ry: number,\n  rotation: number,\n  startAngle: number,\n  endAngle: number,\n) => {\n  const { cos, sin, min, max } = Math;\n  const cosRotation = cos(rotation);\n  const sinRotation = sin(rotation);\n\n  // Rotate parametric equations\n  const xRotated = (t: number) => {\n    return x + rx * cos(t) * cosRotation - ry * sin(t) * sinRotation;\n  };\n  const yRotated = (t: number) => {\n    return y + ry * sin(t) * cosRotation + rx * cos(t) * sinRotation;\n  };\n\n  // Evaluate at start and end angles\n  const startX = xRotated(startAngle);\n  const startY = yRotated(startAngle);\n  const endX = xRotated(endAngle);\n  const endY = yRotated(endAngle);\n\n  // Find minimum and maximum x and y values\n  // Return AABB\n  return {\n    min: { x: min(startX, endX), y: min(startY, endY) },\n    max: { x: max(startX, endX), y: max(startY, endY) },\n  };\n};\n\n/**\n * Returns the angle between two points.\n * @param v0 starting point\n * @param v1 ending point\n * @returns the angle\n */\nconst angleBetween = (v0: Point, v1: Point) => {\n  const { x: v0x, y: v0y } = v0;\n  const { x: v1x, y: v1y } = v1;\n  const p = v0x * v1x + v0y * v1y;\n  const n = Math.sqrt((v0x ** 2 + v0y ** 2) * (v1x ** 2 + v1y ** 2));\n  const sign = v0x * v1y - v0y * v1x < 0 ? -1 : 1;\n  const angle = sign * Math.acos(p / n);\n\n  return angle;\n};\n\n/**\n * Returns properties for an Arc segment.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param distance a [0-1] ratio\n * @returns properties specific to Arc segmentas well as the segment length, point at length and the bounding box\n */\nconst getSegmentProperties = (\n  x1: number,\n  y1: number,\n  RX: number,\n  RY: number,\n  angle: number,\n  LAF: number,\n  SF: number,\n  x: number,\n  y: number,\n  distance?: number,\n) => {\n  const { abs, sin, cos, sqrt, PI } = Math;\n  let rx = abs(RX);\n  let ry = abs(RY);\n  const xRot = ((angle % 360) + 360) % 360;\n  const xRotRad = xRot * (PI / 180);\n\n  if (x1 === x && y1 === y) {\n    return {\n      point: { x, y },\n      length: 0,\n      bbox: { min: { x, y }, max: { x, y } },\n    };\n  }\n\n  if (rx === 0 || ry === 0) {\n    return getLineSegmentProperties(x1, y1, x, y, distance);\n  }\n\n  const dx = (x1 - x) / 2;\n  const dy = (y1 - y) / 2;\n\n  const transformedPoint = {\n    x: cos(xRotRad) * dx + sin(xRotRad) * dy,\n    y: -sin(xRotRad) * dx + cos(xRotRad) * dy,\n  };\n\n  const radiiCheck = transformedPoint.x ** 2 / rx ** 2 + transformedPoint.y ** 2 / ry ** 2;\n\n  if (radiiCheck > 1) {\n    rx *= sqrt(radiiCheck);\n    ry *= sqrt(radiiCheck);\n  }\n\n  const cSquareNumerator = rx ** 2 * ry ** 2 - rx ** 2 * transformedPoint.y ** 2 - ry ** 2 * transformedPoint.x ** 2;\n  const cSquareRootDenom = rx ** 2 * transformedPoint.y ** 2 + ry ** 2 * transformedPoint.x ** 2;\n\n  let cRadicand = cSquareNumerator / cSquareRootDenom;\n  cRadicand = cRadicand < 0 ? 0 : cRadicand;\n  const cCoef = (LAF !== SF ? 1 : -1) * sqrt(cRadicand);\n  const transformedCenter = {\n    x: cCoef * ((rx * transformedPoint.y) / ry),\n    y: cCoef * (-(ry * transformedPoint.x) / rx),\n  };\n\n  const center = {\n    x: cos(xRotRad) * transformedCenter.x - sin(xRotRad) * transformedCenter.y + (x1 + x) / 2,\n    y: sin(xRotRad) * transformedCenter.x + cos(xRotRad) * transformedCenter.y + (y1 + y) / 2,\n  };\n\n  const startVector = {\n    x: (transformedPoint.x - transformedCenter.x) / rx,\n    y: (transformedPoint.y - transformedCenter.y) / ry,\n  };\n\n  const startAngle = angleBetween({ x: 1, y: 0 }, startVector);\n\n  const endVector = {\n    x: (-transformedPoint.x - transformedCenter.x) / rx,\n    y: (-transformedPoint.y - transformedCenter.y) / ry,\n  };\n\n  let sweepAngle = angleBetween(startVector, endVector);\n  if (!SF && sweepAngle > 0) {\n    sweepAngle -= 2 * PI;\n  } else if (SF && sweepAngle < 0) {\n    sweepAngle += 2 * PI;\n  }\n  sweepAngle %= 2 * PI;\n\n  const alpha = startAngle + sweepAngle * (distance || 0);\n  const endAngle = startAngle + sweepAngle;\n  const ellipseComponentX = rx * cos(alpha);\n  const ellipseComponentY = ry * sin(alpha);\n\n  const point = {\n    x: cos(xRotRad) * ellipseComponentX - sin(xRotRad) * ellipseComponentY + center.x,\n    y: sin(xRotRad) * ellipseComponentX + cos(xRotRad) * ellipseComponentY + center.y,\n  };\n\n  // to be used later\n  // point.ellipticalArcStartAngle = startAngle;\n  // point.ellipticalArcEndAngle = startAngle + sweepAngle;\n  // point.ellipticalArcAngle = alpha;\n\n  // point.ellipticalArcCenter = center;\n  // point.resultantRx = rx;\n  // point.resultantRy = ry;\n  // point.length = ellipticalArcLength(rx, ry, sweepAngle);\n  // point.box = minmax(center.x, center.y, rx, ry, xRotRad, startAngle, startAngle + sweepAngle);\n\n  return {\n    point,\n    center,\n    angle: alpha,\n    startAngle,\n    endAngle,\n    radiusX: rx,\n    radiusY: ry,\n    get length() {\n      return ellipticalArcLength(rx, ry, sweepAngle);\n    },\n    get bbox() {\n      return minmax(center.x, center.y, rx, ry, xRotRad, startAngle, startAngle + sweepAngle);\n    },\n  };\n};\n\nexport default getSegmentProperties;\n","import { type Point } from '../types';\n\n/**\n * Tools from bezier.js by Mike 'Pomax' Kamermans\n * @see https://github.com/Pomax/bezierjs\n */\n\nconst ZERO = { x: 0, y: 0 };\n\nconst Tvalues = [\n  -0.0640568928626056260850430826247450385909, 0.0640568928626056260850430826247450385909,\n  -0.1911188674736163091586398207570696318404, 0.1911188674736163091586398207570696318404,\n  -0.3150426796961633743867932913198102407864, 0.3150426796961633743867932913198102407864,\n  -0.4337935076260451384870842319133497124524, 0.4337935076260451384870842319133497124524,\n  -0.5454214713888395356583756172183723700107, 0.5454214713888395356583756172183723700107,\n  -0.6480936519369755692524957869107476266696, 0.6480936519369755692524957869107476266696,\n  -0.7401241915785543642438281030999784255232, 0.7401241915785543642438281030999784255232,\n  -0.8200019859739029219539498726697452080761, 0.8200019859739029219539498726697452080761,\n  -0.8864155270044010342131543419821967550873, 0.8864155270044010342131543419821967550873,\n  -0.9382745520027327585236490017087214496548, 0.9382745520027327585236490017087214496548,\n  -0.9747285559713094981983919930081690617411, 0.9747285559713094981983919930081690617411,\n  -0.9951872199970213601799974097007368118745, 0.9951872199970213601799974097007368118745,\n];\n\nconst Cvalues = [\n  0.1279381953467521569740561652246953718517, 0.1279381953467521569740561652246953718517,\n  0.1258374563468282961213753825111836887264, 0.1258374563468282961213753825111836887264,\n  0.121670472927803391204463153476262425607, 0.121670472927803391204463153476262425607,\n  0.1155056680537256013533444839067835598622, 0.1155056680537256013533444839067835598622,\n  0.1074442701159656347825773424466062227946, 0.1074442701159656347825773424466062227946,\n  0.0976186521041138882698806644642471544279, 0.0976186521041138882698806644642471544279,\n  0.086190161531953275917185202983742667185, 0.086190161531953275917185202983742667185,\n  0.0733464814110803057340336152531165181193, 0.0733464814110803057340336152531165181193,\n  0.0592985849154367807463677585001085845412, 0.0592985849154367807463677585001085845412,\n  0.0442774388174198061686027482113382288593, 0.0442774388174198061686027482113382288593,\n  0.0285313886289336631813078159518782864491, 0.0285313886289336631813078159518782864491,\n  0.0123412297999871995468056670700372915759, 0.0123412297999871995468056670700372915759,\n];\n\ntype DerivedPoint = Point & { t: number };\ntype QuadPoints = [Point, Point, Point, Point, Point, Point];\ntype CubicPoints = [Point, Point, Point, Point, Point, Point, Point, Point];\ntype DerivedQuadPoints = [DerivedPoint, DerivedPoint, DerivedPoint, DerivedPoint, DerivedPoint, DerivedPoint];\ntype DerivedCubicPoints = [\n  DerivedPoint,\n  DerivedPoint,\n  DerivedPoint,\n  DerivedPoint,\n  DerivedPoint,\n  DerivedPoint,\n  DerivedPoint,\n  DerivedPoint,\n];\nexport type QuadCoordinates = [number, number, number, number, number, number];\nexport type CubicCoordinates = [number, number, number, number, number, number, number, number];\n\ntype DeriveCallback = (t: number) => Point;\n\n/**\n *\n * @param points\n * @returns\n */\nconst derive = (points: QuadPoints | CubicPoints) => {\n  const dpoints = [] as (DerivedCubicPoints | DerivedQuadPoints)[];\n  for (let p = points, d = p.length, c = d - 1; d > 1; d -= 1, c -= 1) {\n    const list = [] as unknown as DerivedCubicPoints | DerivedQuadPoints;\n    for (let j = 0; j < c; j += 1) {\n      list.push({\n        x: c * (p[j + 1].x - p[j].x),\n        y: c * (p[j + 1].y - p[j].y),\n        t: 0,\n      });\n    }\n    dpoints.push(list);\n    p = list;\n  }\n  return dpoints;\n};\n\n/**\n *\n * @param points\n * @param t\n */\nconst compute = (points: DerivedQuadPoints | DerivedCubicPoints, t: number) => {\n  // shortcuts\n  /* istanbul ignore next @preserve */\n  if (t === 0) {\n    points[0].t = 0;\n    return points[0];\n  }\n\n  const order = points.length - 1;\n\n  /* istanbul ignore next @preserve */\n  if (t === 1) {\n    points[order].t = 1;\n    return points[order];\n  }\n\n  const mt = 1 - t;\n  let p = points as typeof points | [DerivedPoint, DerivedPoint, DerivedPoint, DerivedPoint];\n\n  // constant?\n  /* istanbul ignore next @preserve */\n  if (order === 0) {\n    points[0].t = t;\n    return points[0];\n  }\n\n  // linear?\n  /* istanbul ignore else @preserve */\n  if (order === 1) {\n    return {\n      x: mt * p[0].x + t * p[1].x,\n      y: mt * p[0].y + t * p[1].y,\n      t,\n    };\n  }\n\n  // quadratic/cubic curve?\n  const mt2 = mt * mt;\n  const t2 = t * t;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  /* istanbul ignore else @preserve */\n  if (order === 2) {\n    p = [p[0], p[1], p[2], ZERO as DerivedPoint];\n    a = mt2;\n    b = mt * t * 2;\n    c = t2;\n  } else if (order === 3) {\n    a = mt2 * mt;\n    b = mt2 * t * 3;\n    c = mt * t2 * 3;\n    d = t * t2;\n  }\n  return {\n    x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n    y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n    t,\n  };\n};\n\nconst arcfn = (derivativeFn: DeriveCallback, t: number) => {\n  const d = derivativeFn(t);\n  const l = d.x * d.x + d.y * d.y;\n\n  return Math.sqrt(l);\n};\n\nconst lengthFn = (derivativeFn: DeriveCallback) => {\n  const z = 0.5;\n  const len = Tvalues.length;\n\n  let sum = 0;\n\n  for (let i = 0, t; i < len; i++) {\n    t = z * Tvalues[i] + z;\n    sum += Cvalues[i] * arcfn(derivativeFn, t);\n  }\n  return z * sum;\n};\n\n/**\n * Returns the length of CubicBezier / Quad segment.\n * @param curve cubic / quad bezier segment\n */\nexport const length = (curve: CubicCoordinates | QuadCoordinates) => {\n  const points = [] as unknown as CubicPoints | QuadPoints;\n  for (let idx = 0, len = curve.length, step = 2; idx < len; idx += step) {\n    points.push({\n      x: curve[idx],\n      y: curve[idx + 1],\n    });\n  }\n  const dpoints = derive(points);\n  return lengthFn((t: number) => {\n    return compute(dpoints[0], t);\n  });\n};\n\n// Precision for consider cubic polynom as quadratic one\nconst CBEZIER_MINMAX_EPSILON = 0.00000001;\n\n/**\n * Returns the most extreme points in a Quad Bezier segment.\n * @param A\n */\n// https://github.com/kpym/SVGPathy/blob/acd1a50c626b36d81969f6e98e8602e128ba4302/lib/box.js#L89\nexport const minmaxQ = (A: [number, number, number]) => {\n  const min = Math.min(A[0], A[2]);\n  const max = Math.max(A[0], A[2]);\n\n  /* istanbul ignore else @preserve */\n  if (A[1] >= A[0] ? A[2] >= A[1] : A[2] <= A[1]) {\n    // if no extremum in ]0,1[\n    return [min, max] as [number, number];\n  }\n\n  // check if the extremum E is min or max\n  const E = (A[0] * A[2] - A[1] * A[1]) / (A[0] - 2 * A[1] + A[2]);\n  return (E < min ? [E, max] : [min, E]) as [number, number];\n};\n\n/**\n * Returns the most extreme points in a Cubic Bezier segment.\n * @param A\n * @see https://github.com/kpym/SVGPathy/blob/acd1a50c626b36d81969f6e98e8602e128ba4302/lib/box.js#L127\n */\nexport const minmaxC = (A: [number, number, number, number]) => {\n  const K = A[0] - 3 * A[1] + 3 * A[2] - A[3];\n\n  // if the polynomial is (almost) quadratic and not cubic\n  /* istanbul ignore else @preserve */\n  if (Math.abs(K) < CBEZIER_MINMAX_EPSILON) {\n    if (A[0] === A[3] && A[0] === A[1]) {\n      // no curve, point targeting same location\n      return [A[0], A[3]] as [number, number];\n    }\n\n    return minmaxQ([A[0], -0.5 * A[0] + 1.5 * A[1], A[0] - 3 * A[1] + 3 * A[2]]);\n  }\n\n  // the reduced discriminant of the derivative\n  const T = -A[0] * A[2] + A[0] * A[3] - A[1] * A[2] - A[1] * A[3] + A[1] * A[1] + A[2] * A[2];\n\n  // if the polynomial is monotone in [0,1]\n  if (T <= 0) {\n    return [Math.min(A[0], A[3]), Math.max(A[0], A[3])] as [number, number];\n  }\n  const S = Math.sqrt(T);\n\n  // potential extrema\n  let min = Math.min(A[0], A[3]);\n  let max = Math.max(A[0], A[3]);\n\n  const L = A[0] - 2 * A[1] + A[2];\n  // check local extrema\n  for (let R = (L + S) / K, i = 1; i <= 2; R = (L - S) / K, i++) {\n    if (R > 0 && R < 1) {\n      // if the extrema is for R in [0,1]\n      const Q =\n        A[0] * (1 - R) * (1 - R) * (1 - R) +\n        A[1] * 3 * (1 - R) * (1 - R) * R +\n        A[2] * 3 * (1 - R) * R * R +\n        A[3] * R * R * R;\n      if (Q < min) {\n        min = Q;\n      }\n      if (Q > max) {\n        max = Q;\n      }\n    }\n  }\n\n  return [min, max] as [number, number];\n};\n","import { length, minmaxC, type CubicCoordinates } from './bezier';\n\n/**\n * Returns a {x,y} point at a given length of a CubicBezier segment.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param t a [0-1] ratio\n * @returns the point at cubic-bezier segment length\n */\nconst getPointAtCubicSegmentLength = ([x1, y1, c1x, c1y, c2x, c2y, x2, y2]: CubicCoordinates, t: number) => {\n  const t1 = 1 - t;\n  return {\n    x: t1 ** 3 * x1 + 3 * t1 ** 2 * t * c1x + 3 * t1 * t ** 2 * c2x + t ** 3 * x2,\n    y: t1 ** 3 * y1 + 3 * t1 ** 2 * t * c1y + 3 * t1 * t ** 2 * c2y + t ** 3 * y2,\n  };\n};\n\n/**\n * Returns the properties of a CubicBezier segment.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param distance the point distance\n * @returns the segment length, point at length and the bounding box\n */\nconst getSegmentProperties = (\n  x1: number,\n  y1: number,\n  c1x: number,\n  c1y: number,\n  c2x: number,\n  c2y: number,\n  x2: number,\n  y2: number,\n  distance?: number,\n) => {\n  const distanceIsNumber = typeof distance === 'number';\n  let POINT = { x: x1, y: y1 };\n  const getLength = () => length([x1, y1, c1x, c1y, c2x, c2y, x2, y2]);\n\n  if (distanceIsNumber) {\n    const currentLength = getLength();\n    if (distance <= 0) {\n      // first point already defined\n    } else if (distance >= currentLength) {\n      POINT = { x: x2, y: y2 };\n    } else {\n      POINT = getPointAtCubicSegmentLength([x1, y1, c1x, c1y, c2x, c2y, x2, y2], distance / currentLength);\n    }\n  }\n\n  return {\n    point: POINT,\n    get length() {\n      return getLength();\n    },\n    get bbox() {\n      const cxMinMax = minmaxC([x1, c1x, c2x, x2]);\n      const cyMinMax = minmaxC([y1, c1y, c2y, y2]);\n      return {\n        min: { x: cxMinMax[0], y: cyMinMax[0] },\n        max: { x: cxMinMax[1], y: cyMinMax[1] },\n      };\n    },\n  };\n};\n\nexport default getSegmentProperties;\n","import { length, minmaxQ, type QuadCoordinates } from './bezier';\n\n/**\n * Returns the {x,y} coordinates of a point at a\n * given length of a quadratic-bezier segment.\n *\n * @see https://github.com/substack/point-at-length\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param cx the control point X\n * @param cy the control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param t a [0-1] ratio\n * @returns the requested {x,y} coordinates\n */\nconst getPointAtQuadSegmentLength = ([x1, y1, cx, cy, x2, y2]: QuadCoordinates, t: number) => {\n  const t1 = 1 - t;\n  return {\n    x: t1 ** 2 * x1 + 2 * t1 * t * cx + t ** 2 * x2,\n    y: t1 ** 2 * y1 + 2 * t1 * t * cy + t ** 2 * y2,\n  };\n};\n\n/**\n * Returns properties of a QuadraticBezier segment.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param cx the control point X\n * @param cy the control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param distance the point distance\n * @returns the segment length, point at length and the bounding box\n */\nconst getSegmentProperties = (\n  x1: number,\n  y1: number,\n  cx: number,\n  cy: number,\n  x2: number,\n  y2: number,\n  distance: number | undefined,\n) => {\n  const distanceIsNumber = typeof distance === 'number';\n  let POINT = { x: x1, y: y1 };\n  const getLength = () => length([x1, y1, cx, cy, x2, y2]);\n\n  if (distanceIsNumber) {\n    const currentLength = getLength();\n\n    if (distance <= 0) {\n      // first point already defined\n    } else if (distance >= currentLength) {\n      POINT = { x: x2, y: y2 };\n    } else {\n      POINT = getPointAtQuadSegmentLength([x1, y1, cx, cy, x2, y2], distance / currentLength);\n    }\n  }\n\n  return {\n    point: POINT,\n    get length() {\n      return getLength();\n    },\n    get bbox() {\n      const cxMinMax = minmaxQ([x1, cx, x2]);\n      const cyMinMax = minmaxQ([y1, cy, y2]);\n      return {\n        min: { x: cxMinMax[0], y: cyMinMax[0] },\n        max: { x: cxMinMax[1], y: cyMinMax[1] },\n      };\n    },\n  };\n};\n\nexport default getSegmentProperties;\n","const DISTANCE_EPSILON = 0.00001;\n\nexport default DISTANCE_EPSILON;\n","import type { MSegment, PathArray, PathSegment, Point } from '../types';\n// import type { LengthFactory } from '../interface';\nimport normalizePath from '../process/normalizePath';\nimport getLineSegmentProperties from '../math/lineTools';\nimport getArcSegmentProperties from '../math/arcTools';\nimport getCubicSegmentProperties from '../math/cubicTools';\nimport getQuadSegmentProperties from '../math/quadTools';\nimport DISTANCE_EPSILON from './distanceEpsilon';\n\n/**\n * Returns a {x,y} point at a given length\n * of a shape, the shape total length and\n * the shape minimum and maximum {x,y} coordinates.\n *\n * @param pathInput the `pathArray` to look into\n * @param distance the length of the shape to look at\n * @returns the path length, point, min & max\n */\nconst pathFactory = (pathInput: string | PathArray, distance?: number) => {\n  const path = normalizePath(pathInput);\n  const distanceIsNumber = typeof distance === 'number';\n  let isM = false;\n  let data = [] as number[];\n  let pathCommand = 'M';\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n  let seg = path[0] as PathSegment;\n  const MIN = [] as Point[];\n  const MAX = [] as Point[];\n  let min = { x: 0, y: 0 };\n  let max = { x: 0, y: 0 };\n  let POINT = min;\n  let LENGTH = 0;\n  let props = {\n    point: { x: 0, y: 0 },\n    length: 0,\n    bbox: {\n      min: { x: 0, y: 0 },\n      max: { x: 0, y: 0 },\n    },\n  };\n\n  for (let i = 0, ll = path.length; i < ll; i += 1) {\n    seg = path[i];\n    [pathCommand] = seg;\n    isM = pathCommand === 'M';\n    data = !isM ? [x, y, ...(seg.slice(1) as number[])] : data;\n\n    if (distanceIsNumber && distance < DISTANCE_EPSILON) {\n      POINT = min;\n    }\n\n    // this segment is always ZERO\n    /* istanbul ignore else @preserve */\n    if (isM) {\n      // remember mx, my for Z\n      [, mx, my] = seg as MSegment;\n      min = { x: mx, y: my };\n      max = { x: mx, y: my };\n      props = {\n        point: min,\n        length: 0,\n        bbox: { min, max },\n      };\n    } else if (pathCommand === 'L') {\n      props = getLineSegmentProperties(\n        ...(data as [number, number, number, number]),\n        distanceIsNumber ? distance - LENGTH : undefined,\n      );\n    } else if (pathCommand === 'A') {\n      props = getArcSegmentProperties(\n        ...(data as [number, number, number, number, number, number, number, number, number]),\n        distanceIsNumber ? distance - LENGTH : undefined,\n      );\n    } else if (pathCommand === 'C') {\n      props = getCubicSegmentProperties(\n        ...(data as [number, number, number, number, number, number, number, number]),\n        distanceIsNumber ? distance - LENGTH : undefined,\n      );\n    } else if (pathCommand === 'Q') {\n      props = getQuadSegmentProperties(\n        ...(data as [number, number, number, number, number, number]),\n        distanceIsNumber ? distance - LENGTH : undefined,\n      );\n    } else if (pathCommand === 'Z') {\n      data = [x, y, mx, my];\n      props = getLineSegmentProperties(\n        ...(data as [number, number, number, number]),\n        distanceIsNumber ? distance - LENGTH : undefined,\n      );\n    }\n\n    if (distanceIsNumber && LENGTH < distance && LENGTH + props.length >= distance) {\n      POINT = props.point;\n    }\n\n    MIN.push(props.bbox.min);\n    MAX.push(props.bbox.max);\n    LENGTH += props.length;\n\n    [x, y] = pathCommand !== 'Z' ? (seg.slice(-2) as [number, number]) : [mx, my];\n  }\n\n  // native `getPointAtLength` behavior when the given distance\n  // is higher than total length\n  if (distanceIsNumber && distance > LENGTH - DISTANCE_EPSILON) {\n    POINT = { x, y };\n  }\n\n  return {\n    point: POINT,\n    length: LENGTH,\n    get bbox() {\n      return {\n        min: {\n          x: Math.min(...MIN.map(n => n.x)),\n          y: Math.min(...MIN.map(n => n.y)),\n        },\n        max: {\n          x: Math.max(...MAX.map(n => n.x)),\n          y: Math.max(...MAX.map(n => n.y)),\n        },\n      };\n    },\n  };\n};\n\nexport default pathFactory;\n","import { PathBBox } from 'src/interface';\nimport { PathArray } from 'src/types';\nimport pathFactory from './pathFactory';\n\n/**\n * Returns the bounding box of a shape.\n *\n * @param path the shape `pathArray`\n * @returns the length of the cubic-bezier segment\n */\nconst getPathBBox = (path: PathArray | string): PathBBox => {\n  if (!path) {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n      x2: 0,\n      y2: 0,\n      cx: 0,\n      cy: 0,\n      cz: 0,\n    };\n  }\n\n  const props = pathFactory(path);\n  const {\n    min: { x: xMin, y: yMin },\n    max: { x: xMax, y: yMax },\n  } = props.bbox;\n\n  const width = xMax - xMin;\n  const height = yMax - yMin;\n\n  return {\n    width,\n    height,\n    x: xMin,\n    y: yMin,\n    x2: xMax,\n    y2: yMax,\n    cx: xMin + width / 2,\n    cy: yMin + height / 2,\n    // an estimted guess\n    cz: Math.max(width, height) + Math.min(width, height) / 2,\n  };\n};\nexport default getPathBBox;\n","import { CSegment, PathArray, PathCommand } from '../types';\n\n/**\n * Splits an extended A (arc-to) segment into two cubic-bezier segments.\n *\n * @param path the `pathArray` this segment belongs to\n * @param allPathCommands all previous path commands\n * @param i the segment index\n */\nconst fixArc = (path: PathArray, allPathCommands: PathCommand[], i: number) => {\n  if (path[i].length > 7) {\n    path[i].shift();\n    const segment = path[i];\n    let ni = i; // ESLint\n    while (segment.length) {\n      // if created multiple C:s, their original seg is saved\n      allPathCommands[i] = 'A';\n      path.splice((ni += 1), 0, ['C', ...segment.splice(0, 6)] as CSegment);\n    }\n    path.splice(i, 1);\n  }\n};\nexport default fixArc;\n","import { CurveArray } from '../types';\nimport isNormalizedArray from './isNormalizedArray';\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with all C (cubic bezier) segments.\n *\n * @param path the `Array` to be checked\n * @returns iteration result\n */\nconst isCurveArray = (path: unknown): path is CurveArray => {\n  // `isPathArray` also checks if it's `Array`\n  return isNormalizedArray(path) && path.every(([pc]) => 'MC'.includes(pc));\n};\nexport default isCurveArray;\n","/**\n * Returns an {x,y} vector rotated by a given\n * angle in radian.\n *\n * @param x the initial vector x\n * @param y the initial vector y\n * @param rad the radian vector angle\n * @returns the rotated vector\n */\nconst rotateVector = (x: number, y: number, rad: number): { x: number; y: number } => {\n  const X = x * Math.cos(rad) - y * Math.sin(rad);\n  const Y = x * Math.sin(rad) + y * Math.cos(rad);\n  return { x: X, y: Y };\n};\n\nexport default rotateVector;\n","import rotateVector from '../math/rotateVector';\n\n/**\n * Converts A (arc-to) segments to C (cubic-bezier-to).\n *\n * For more information of where this math came from visit:\n * http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n *\n * @param X1 the starting x position\n * @param Y1 the starting y position\n * @param RX x-radius of the arc\n * @param RY y-radius of the arc\n * @param angle x-axis-rotation of the arc\n * @param LAF large-arc-flag of the arc\n * @param SF sweep-flag of the arc\n * @param X2 the ending x position\n * @param Y2 the ending y position\n * @param recursive the parameters needed to split arc into 2 segments\n * @return the resulting cubic-bezier segment(s)\n */\nconst arcToCubic = (\n  X1: number,\n  Y1: number,\n  RX: number,\n  RY: number,\n  angle: number,\n  LAF: number,\n  SF: number,\n  X2: number,\n  Y2: number,\n  recursive?: [number, number, number, number],\n): number[] => {\n  let x1 = X1;\n  let y1 = Y1;\n  let rx = RX;\n  let ry = RY;\n  let x2 = X2;\n  let y2 = Y2;\n  // for more information of where this Math came from visit:\n  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n  const d120 = (Math.PI * 120) / 180;\n\n  const rad = (Math.PI / 180) * (+angle || 0);\n  let res = [] as number[];\n  let xy;\n  let f1;\n  let f2;\n  let cx;\n  let cy;\n\n  if (!recursive) {\n    xy = rotateVector(x1, y1, -rad);\n    x1 = xy.x;\n    y1 = xy.y;\n    xy = rotateVector(x2, y2, -rad);\n    x2 = xy.x;\n    y2 = xy.y;\n\n    const x = (x1 - x2) / 2;\n    const y = (y1 - y2) / 2;\n    let h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n    if (h > 1) {\n      h = Math.sqrt(h);\n      rx *= h;\n      ry *= h;\n    }\n    const rx2 = rx * rx;\n    const ry2 = ry * ry;\n\n    const k =\n      (LAF === SF ? -1 : 1) *\n      Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));\n\n    cx = (k * rx * y) / ry + (x1 + x2) / 2;\n    cy = (k * -ry * x) / rx + (y1 + y2) / 2;\n    // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise\n    f1 = Math.asin(((((y1 - cy) / ry) * 10 ** 9) >> 0) / 10 ** 9);\n    // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise\n    f2 = Math.asin(((((y2 - cy) / ry) * 10 ** 9) >> 0) / 10 ** 9);\n\n    f1 = x1 < cx ? Math.PI - f1 : f1;\n    f2 = x2 < cx ? Math.PI - f2 : f2;\n    if (f1 < 0) f1 = Math.PI * 2 + f1;\n    if (f2 < 0) f2 = Math.PI * 2 + f2;\n    if (SF && f1 > f2) {\n      f1 -= Math.PI * 2;\n    }\n    if (!SF && f2 > f1) {\n      f2 -= Math.PI * 2;\n    }\n  } else {\n    [f1, f2, cx, cy] = recursive;\n  }\n  let df = f2 - f1;\n  if (Math.abs(df) > d120) {\n    const f2old = f2;\n    const x2old = x2;\n    const y2old = y2;\n    f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);\n    x2 = cx + rx * Math.cos(f2);\n    y2 = cy + ry * Math.sin(f2);\n    res = arcToCubic(x2, y2, rx, ry, angle, 0, SF, x2old, y2old, [f2, f2old, cx, cy]);\n  }\n  df = f2 - f1;\n  const c1 = Math.cos(f1);\n  const s1 = Math.sin(f1);\n  const c2 = Math.cos(f2);\n  const s2 = Math.sin(f2);\n  const t = Math.tan(df / 4);\n  const hx = (4 / 3) * rx * t;\n  const hy = (4 / 3) * ry * t;\n  const m1 = [x1, y1];\n  const m2 = [x1 + hx * s1, y1 - hy * c1];\n  const m3 = [x2 + hx * s2, y2 - hy * c2];\n  const m4 = [x2, y2];\n  m2[0] = 2 * m1[0] - m2[0];\n  m2[1] = 2 * m1[1] - m2[1];\n  if (recursive) {\n    return [...m2, ...m3, ...m4, ...res];\n  }\n  res = [...m2, ...m3, ...m4, ...res];\n  const newres = [];\n  for (let i = 0, ii = res.length; i < ii; i += 1) {\n    newres[i] = i % 2 ? rotateVector(res[i - 1], res[i], rad).y : rotateVector(res[i], res[i + 1], rad).x;\n  }\n  return newres;\n};\nexport default arcToCubic;\n","/**\n * Converts a Q (quadratic-bezier) segment to C (cubic-bezier).\n *\n * @param x1 curve start x\n * @param y1 curve start y\n * @param qx control point x\n * @param qy control point y\n * @param x2 curve end x\n * @param y2 curve end y\n * @returns the cubic-bezier segment\n */\nconst quadToCubic = (\n  x1: number,\n  y1: number,\n  qx: number,\n  qy: number,\n  x2: number,\n  y2: number,\n): [number, number, number, number, number, number] => {\n  const r13 = 1 / 3;\n  const r23 = 2 / 3;\n  return [\n    r13 * x1 + r23 * qx, // cpx1\n    r13 * y1 + r23 * qy, // cpy1\n    r13 * x2 + r23 * qx, // cpx2\n    r13 * y2 + r23 * qy, // cpy2\n    x2,\n    y2, // x,y\n  ];\n};\nexport default quadToCubic;\n","import midPoint from '../math/midPoint';\n\n/**\n * Converts an L (line-to) segment to C (cubic-bezier).\n *\n * @param x1 line start x\n * @param y1 line start y\n * @param x2 line end x\n * @param y2 line end y\n * @returns the cubic-bezier segment\n */\nconst lineToCubic = (x1: number, y1: number, x2: number, y2: number) => {\n  const c1 = midPoint([x1, y1], [x2, y2], 1.0 / 3.0);\n  const c2 = midPoint([x1, y1], [x2, y2], 2.0 / 3.0);\n  return [...c1, ...c2, x2, y2];\n};\nexport default lineToCubic;\n","import arcToCubic from './arcToCubic';\nimport quadToCubic from './quadToCubic';\nimport lineToCubic from './lineToCubic';\nimport type { CSegment, MSegment, PathSegment } from '../types';\nimport type { ParserParams } from '../interface';\n\n/**\n * Converts any segment to C (cubic-bezier).\n *\n * @param segment the source segment\n * @param params the source segment parameters\n * @returns the cubic-bezier segment\n */\nconst segmentToCubic = (segment: PathSegment, params: ParserParams): MSegment | CSegment => {\n  const [pathCommand] = segment;\n  const values = segment.slice(1).map(Number);\n  const [x, y] = values;\n  let args;\n  const { x1: px1, y1: py1, x: px, y: py } = params;\n\n  if (!'TQ'.includes(pathCommand)) {\n    params.qx = null;\n    params.qy = null;\n  }\n\n  if (pathCommand === 'M') {\n    params.x = x;\n    params.y = y;\n    return segment;\n  } else if (pathCommand === 'A') {\n    args = [px1, py1, ...values] as [number, number, number, number, number, number, number, number, number];\n    return ['C', ...arcToCubic(...args)] as CSegment;\n  } else if (pathCommand === 'Q') {\n    params.qx = x;\n    params.qy = y;\n    args = [px1, py1, ...values] as [number, number, number, number, number, number];\n    return ['C', ...quadToCubic(...args)] as CSegment;\n  } else if (pathCommand === 'L') {\n    return ['C', ...lineToCubic(px1, py1, x, y)] as CSegment;\n  } else if (pathCommand === 'Z') {\n    return ['C', ...lineToCubic(px1, py1, px, py)] as CSegment;\n  }\n\n  return segment as MSegment | CSegment;\n};\nexport default segmentToCubic;\n","import fixArc from '../process/fixArc';\nimport isCurveArray from '../util/isCurveArray';\nimport normalizePath from '../process/normalizePath';\nimport segmentToCubic from '../process/segmentToCubic';\nimport paramsParser from '../parser/paramsParser';\nimport { CurveArray, PathArray, PathCommand } from '../types';\n\n/**\n * Parses a path string value or 'pathArray' and returns a new one\n * in which all segments are converted to cubic-bezier.\n *\n * In addition, un-necessary `Z` segment is removed if previous segment\n * extends to the `M` segment.\n *\n * @param pathInput the string to be parsed or 'pathArray'\n * @returns the resulted `pathArray` converted to cubic-bezier\n */\nconst pathToCurve = (pathInput: string | PathArray): CurveArray => {\n  /* istanbul ignore else */\n  if (isCurveArray(pathInput)) {\n    return pathInput.slice(0) as CurveArray;\n  }\n\n  const path = normalizePath(pathInput);\n  const params = { ...paramsParser };\n  const allPathCommands = [] as PathCommand[];\n  let pathCommand = ''; // ts-lint\n  let ii = path.length;\n\n  for (let i = 0; i < ii; i += 1) {\n    [pathCommand] = path[i];\n    allPathCommands[i] = pathCommand as PathCommand;\n\n    path[i] = segmentToCubic(path[i], params);\n\n    fixArc(path, allPathCommands, i);\n    ii = path.length;\n\n    const segment = path[i];\n    const seglen = segment.length;\n    params.x1 = +segment[seglen - 2];\n    params.y1 = +segment[seglen - 1];\n    params.x2 = +segment[seglen - 4] || params.x1;\n    params.y2 = +segment[seglen - 3] || params.y1;\n  }\n\n  return path as CurveArray;\n};\nexport default pathToCurve;\n","import pathToCurve from '../convert/pathToCurve';\nimport type { PathArray } from '../types';\n\n/**\n * Returns the area of a single cubic-bezier segment.\n *\n * http://objectmix.com/graphics/133553-area-closed-bezier-curve.html\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the area of the cubic-bezier segment\n */\nconst getCubicSegArea = (\n  x1: number,\n  y1: number,\n  c1x: number,\n  c1y: number,\n  c2x: number,\n  c2y: number,\n  x2: number,\n  y2: number,\n) => {\n  return (\n    (3 *\n      ((y2 - y1) * (c1x + c2x) -\n        (x2 - x1) * (c1y + c2y) +\n        c1y * (x1 - c2x) -\n        c1x * (y1 - c2y) +\n        y2 * (c2x + x1 / 3) -\n        x2 * (c2y + y1 / 3))) /\n    20\n  );\n};\n\n/**\n * Returns the area of a shape.\n *\n * @author Jürg Lehni & Jonathan Puckey\n *\n * @see https://github.com/paperjs/paper.js/blob/develop/src/path/Path.js\n *\n * @param path the shape `pathArray`\n * @returns the length of the cubic-bezier segment\n */\nconst getPathArea = (path: PathArray) => {\n  let x = 0;\n  let y = 0;\n  let len = 0;\n\n  return pathToCurve(path)\n    .map(seg => {\n      switch (seg[0]) {\n        case 'M':\n          [, x, y] = seg;\n          return 0;\n        default:\n          len = getCubicSegArea(x, y, ...(seg.slice(1) as [number, number, number, number, number, number]));\n          [x, y] = seg.slice(-2) as [number, number];\n          return len;\n      }\n    })\n    .reduce((a, b) => a + b, 0);\n};\nexport default getPathArea;\n","import type { PathArray } from '../types';\nimport pathFactory from './pathFactory';\n\n/**\n * Returns the shape total length, or the equivalent to `shape.getTotalLength()`.\n *\n * The `normalizePath` version is lighter, faster, more efficient and more accurate\n * with paths that are not `curveArray`.\n *\n * @param pathInput the target `pathArray`\n * @returns the shape total length\n */\nconst getTotalLength = (pathInput: string | PathArray): number => {\n  return pathFactory(pathInput).length;\n};\nexport default getTotalLength;\n","import getPathArea from './getPathArea';\nimport pathToCurve from '../convert/pathToCurve';\nimport type { PathArray } from '../types';\n\n/**\n * Check if a path is drawn clockwise and returns true if so,\n * false otherwise.\n *\n * @param path the path string or `pathArray`\n * @returns true when clockwise or false if not\n */\nconst getDrawDirection = (path: string | PathArray) => {\n  return getPathArea(pathToCurve(path)) >= 0;\n};\n\nexport default getDrawDirection;\n","import type { PathArray } from '../types';\nimport pathFactory from './pathFactory';\n\n/**\n * Returns [x,y] coordinates of a point at a given length of a shape.\n *\n * @param pathInput the `pathArray` to look into\n * @param distance the length of the shape to look at\n * @returns the requested {x, y} point coordinates\n */\nconst getPointAtLength = (pathInput: string | PathArray, distance: number) => {\n  return pathFactory(pathInput, distance).point;\n};\nexport default getPointAtLength;\n","import type { PathArray, PathSegment } from '../types';\nimport type { SegmentProperties } from '../interface';\nimport parsePathString from '../parser/parsePathString';\nimport getTotalLength from './getTotalLength';\n\n/**\n * Returns the segment, its index and length as well as\n * the length to that segment at a given length in a path.\n *\n * @param pathInput target `pathArray`\n * @param distance the given length\n * @returns the requested properties\n */\nconst getPropertiesAtLength = (pathInput: string | PathArray, distance?: number): SegmentProperties => {\n  const pathArray = parsePathString(pathInput);\n\n  let pathTemp = pathArray.slice(0) as PathArray;\n  let pathLength = getTotalLength(pathTemp);\n  let index = pathTemp.length - 1;\n  let lengthAtSegment = 0;\n  let length = 0;\n  let segment = pathArray[0] as PathSegment;\n  const [x, y] = segment.slice(-2) as [number, number];\n  const point = { x, y };\n\n  // If the path is empty, return 0.\n  if (index <= 0 || !distance || !Number.isFinite(distance)) {\n    return {\n      segment,\n      index: 0,\n      length,\n      point,\n      lengthAtSegment,\n    };\n  }\n\n  if (distance >= pathLength) {\n    pathTemp = pathArray.slice(0, -1) as PathArray;\n    lengthAtSegment = getTotalLength(pathTemp);\n    length = pathLength - lengthAtSegment;\n    return {\n      segment: pathArray[index],\n      index,\n      length,\n      lengthAtSegment,\n    };\n  }\n\n  const segments = [] as SegmentProperties[];\n  while (index > 0) {\n    segment = pathTemp[index];\n    pathTemp = pathTemp.slice(0, -1) as PathArray;\n    lengthAtSegment = getTotalLength(pathTemp);\n    length = pathLength - lengthAtSegment;\n    pathLength = lengthAtSegment;\n    segments.push({\n      segment,\n      index,\n      length,\n      lengthAtSegment,\n    });\n    index -= 1;\n  }\n\n  return segments.find(({ lengthAtSegment: l }) => l <= distance) as SegmentProperties;\n};\n\nexport default getPropertiesAtLength;\n","import type { PathArray } from '../types';\nimport type { PointProperties } from '../interface';\nimport getPointAtLength from './getPointAtLength';\nimport getPropertiesAtLength from './getPropertiesAtLength';\nimport getTotalLength from './getTotalLength';\nimport parsePathString from '../parser/parsePathString';\nimport normalizePath from '../process/normalizePath';\n\n/**\n * Returns the point and segment in path closest to a given point as well as\n * the distance to the path stroke.\n *\n * @see https://bl.ocks.org/mbostock/8027637\n *\n * @param pathInput target `pathArray`\n * @param point the given point\n * @returns the requested properties\n */\nconst getPropertiesAtPoint = (pathInput: string | PathArray, point: { x: number; y: number }): PointProperties => {\n  const path = parsePathString(pathInput);\n  const normalPath = normalizePath(path);\n  const pathLength = getTotalLength(path);\n  const distanceTo = (p: { x: number; y: number }) => {\n    const dx = p.x - point.x;\n    const dy = p.y - point.y;\n    return dx * dx + dy * dy;\n  };\n  let precision = 8;\n  let scan: { x: number; y: number };\n  let closest = { x: 0, y: 0 }; // make TS happy\n  let scanDistance = 0;\n  let bestLength = 0;\n  let bestDistance = Infinity;\n\n  // linear scan for coarse approximation\n  for (let scanLength = 0; scanLength <= pathLength; scanLength += precision) {\n    scan = getPointAtLength(normalPath, scanLength);\n    scanDistance = distanceTo(scan);\n\n    if (scanDistance < bestDistance) {\n      closest = scan;\n      bestLength = scanLength;\n      bestDistance = scanDistance;\n    }\n  }\n\n  // binary search for precise estimate\n  precision /= 2;\n  let before: { x: number; y: number };\n  let after: { x: number; y: number };\n  let beforeLength = 0;\n  let afterLength = 0;\n  let beforeDistance = 0;\n  let afterDistance = 0;\n\n  while (precision > 0.000001) {\n    beforeLength = bestLength - precision;\n    before = getPointAtLength(normalPath, beforeLength);\n    beforeDistance = distanceTo(before);\n    afterLength = bestLength + precision;\n    after = getPointAtLength(normalPath, afterLength);\n    afterDistance = distanceTo(after);\n\n    if (beforeLength >= 0 && beforeDistance < bestDistance) {\n      closest = before;\n      bestLength = beforeLength;\n      bestDistance = beforeDistance;\n    } else if (afterLength <= pathLength && afterDistance < bestDistance) {\n      closest = after;\n      bestLength = afterLength;\n      bestDistance = afterDistance;\n    } else {\n      precision /= 2;\n    }\n    if (precision < 0.00001) break;\n  }\n\n  const segment = getPropertiesAtLength(path, bestLength);\n  const distance = Math.sqrt(bestDistance);\n\n  return { closest, distance, segment };\n};\n\nexport default getPropertiesAtPoint;\n","import type { PathArray } from '../types';\nimport getPropertiesAtPoint from './getPropertiesAtPoint';\n\n/**\n * Returns the point in path closest to a given point.\n *\n * @param pathInput target `pathArray`\n * @param point the given point\n * @returns the best match\n */\nconst getClosestPoint = (pathInput: string | PathArray, point: { x: number; y: number }) => {\n  return getPropertiesAtPoint(pathInput, point).closest;\n};\n\nexport default getClosestPoint;\n","import type { SegmentProperties } from '../interface';\nimport type { PathArray } from '../types';\nimport getPropertiesAtPoint from './getPropertiesAtPoint';\n\n/**\n * Returns the path segment which contains a given point.\n *\n * @param path the `pathArray` to look into\n * @param point the point of the shape to look for\n * @returns the requested segment\n */\nconst getSegmentOfPoint = (\n  path: string | PathArray,\n  point: { x: number; y: number },\n): SegmentProperties | undefined => {\n  return getPropertiesAtPoint(path, point).segment;\n};\nexport default getSegmentOfPoint;\n","import type { PathArray, PathSegment } from '../types';\nimport getPropertiesAtLength from './getPropertiesAtLength';\n\n/**\n * Returns the segment at a given length.\n *\n * @param pathInput the target `pathArray`\n * @param distance the distance in path to look at\n * @returns the requested segment\n */\nconst getSegmentAtLength = (pathInput: string | PathArray, distance?: number): PathSegment | undefined => {\n  return getPropertiesAtLength(pathInput, distance).segment;\n};\n\nexport default getSegmentAtLength;\n","import type { PathArray } from '../types';\nimport getPropertiesAtPoint from './getPropertiesAtPoint';\nimport DISTANCE_EPSILON from './distanceEpsilon';\n\n/**\n * Checks if a given point is in the stroke of a path.\n *\n * @param pathInput target path\n * @param point the given `{x,y}` point\n * @returns the query result\n */\nconst isPointInStroke = (pathInput: string | PathArray, point: { x: number; y: number }) => {\n  const { distance } = getPropertiesAtPoint(pathInput, point);\n  return Math.abs(distance) < DISTANCE_EPSILON; // 0.01 might be more permissive\n};\nexport default isPointInStroke;\n","import scanSegment from '../parser/scanSegment';\nimport skipSpaces from '../parser/skipSpaces';\nimport PathParser from '../parser/pathParser';\n\n/**\n * Parses a path string value to determine its validity\n * then returns true if it's valid or false otherwise.\n *\n * @param pathString the path string to be parsed\n * @returns the path string validity\n */\nconst isValidPath = (pathString: string) => {\n  if (typeof pathString !== 'string' || !pathString.length) {\n    return false;\n  }\n\n  const path = new PathParser(pathString);\n\n  skipSpaces(path);\n\n  while (path.index < path.max && !path.err.length) {\n    scanSegment(path);\n  }\n\n  return !path.err.length && 'mM'.includes(path.segments[0][0]);\n};\nexport default isValidPath;\n","import type { RelativeArray } from '../types';\nimport isPathArray from './isPathArray';\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with relative values.\n *\n * @param path the `pathArray` to be checked\n * @returns iteration result\n */\nconst isRelativeArray = (path: unknown): path is RelativeArray => {\n  return (\n    isPathArray(path) &&\n    // `isPathArray` checks if it's `Array`\n    path.slice(1).every(([pc]) => pc === pc.toLowerCase())\n  );\n};\nexport default isRelativeArray;\n","import type { ShapeParams } from '../interface';\n\n/**\n * Supported shapes and their specific parameters.\n */\nconst shapeParams: ShapeParams = {\n  line: ['x1', 'y1', 'x2', 'y2'],\n  circle: ['cx', 'cy', 'r'],\n  ellipse: ['cx', 'cy', 'rx', 'ry'],\n  rect: ['width', 'height', 'x', 'y', 'rx', 'ry'],\n  polygon: ['points'],\n  polyline: ['points'],\n  glyph: ['d'],\n};\n\nexport default shapeParams;\n","import type { CircleAttr, EllipseAttr, GlyphAttr, LineAttr, PolyAttr, RectAttr, ShapeParams } from '../interface';\nimport type { PathArray, PathSegment, ShapeOps, ShapeTypes } from '../types';\nimport error from '../parser/error';\nimport parsePathString from '../parser/parsePathString';\nimport shapeParams from './shapeParams';\nimport isPathArray from './isPathArray';\n\n/**\n * Returns a new `pathArray` from line attributes.\n *\n * @param attr shape configuration\n * @returns a new line `pathArray`\n */\nexport const getLinePath = (attr: LineAttr): PathArray => {\n  let { x1, y1, x2, y2 } = attr;\n  [x1, y1, x2, y2] = [x1, y1, x2, y2].map(a => +a);\n  return [\n    ['M', x1, y1],\n    ['L', x2, y2],\n  ];\n};\n\n/**\n * Returns a new `pathArray` like from polyline/polygon attributes.\n *\n * @param attr shape configuration\n * @return a new polygon/polyline `pathArray`\n */\nexport const getPolyPath = (attr: PolyAttr): PathArray => {\n  const pathArray = [] as PathSegment[];\n  const points = (attr.points || '')\n    .trim()\n    .split(/[\\s|,]/)\n    .map(a => +a);\n\n  let index = 0;\n  while (index < points.length) {\n    pathArray.push([index ? 'L' : 'M', points[index], points[index + 1]]);\n    index += 2;\n  }\n\n  return (attr.type === 'polygon' ? [...pathArray, ['z']] : pathArray) as PathArray;\n};\n\n/**\n * Returns a new `pathArray` from circle attributes.\n *\n * @param attr shape configuration\n * @return a circle `pathArray`\n */\nexport const getCirclePath = (attr: CircleAttr): PathArray => {\n  let { cx, cy, r } = attr;\n  [cx, cy, r] = [cx, cy, r].map(a => +a);\n\n  return [\n    ['M', cx - r, cy],\n    ['a', r, r, 0, 1, 0, 2 * r, 0],\n    ['a', r, r, 0, 1, 0, -2 * r, 0],\n  ];\n};\n\n/**\n * Returns a new `pathArray` from ellipse attributes.\n *\n * @param attr shape configuration\n * @return an ellipse `pathArray`\n */\nexport const getEllipsePath = (attr: EllipseAttr): PathArray => {\n  let { cx, cy } = attr;\n  let rx = attr.rx || 0;\n  let ry = attr.ry || rx;\n  [cx, cy, rx, ry] = [cx, cy, rx, ry].map(a => +a);\n\n  return [\n    ['M', cx - rx, cy],\n    ['a', rx, ry, 0, 1, 0, 2 * rx, 0],\n    ['a', rx, ry, 0, 1, 0, -2 * rx, 0],\n  ];\n};\n\n/**\n * Returns a new `pathArray` like from rect attributes.\n *\n * @param attr object with properties above\n * @return a new `pathArray` from `<rect>` attributes\n */\nexport const getRectanglePath = (attr: RectAttr): PathArray => {\n  const x = +attr.x || 0;\n  const y = +attr.y || 0;\n  const w = +attr.width;\n  const h = +attr.height;\n  let rx = +(attr.rx || 0);\n  let ry = +(attr.ry || rx);\n\n  // Validity checks from http://www.w3.org/TR/SVG/shapes.html#RectElement:\n  if (rx || ry) {\n    // rx = !rx ? ry : rx;\n    // ry = !ry ? rx : ry;\n\n    /* istanbul ignore else @preserve */\n    if (rx * 2 > w) rx -= (rx * 2 - w) / 2;\n    /* istanbul ignore else @preserve */\n    if (ry * 2 > h) ry -= (ry * 2 - h) / 2;\n\n    return [\n      ['M', x + rx, y],\n      ['h', w - rx * 2],\n      ['s', rx, 0, rx, ry],\n      ['v', h - ry * 2],\n      ['s', 0, ry, -rx, ry],\n      ['h', -w + rx * 2],\n      ['s', -rx, 0, -rx, -ry],\n      ['v', -h + ry * 2],\n      ['s', 0, -ry, rx, -ry],\n    ];\n  }\n\n  return [['M', x, y], ['h', w], ['v', h], ['H', x], ['Z']];\n};\n\n/**\n * Returns a new `pathArray` created from attributes of a `<line>`, `<polyline>`,\n * `<polygon>`, `<rect>`, `<ellipse>`, `<circle>`, <path> or `<glyph>`.\n *\n * The default `ownerDocument` is your current `document` browser page,\n * if you want to use in server-side using `jsdom`, you can pass the\n * `jsdom` `document` to `ownDocument`.\n *\n * It can also work with an options object, see the type below\n *\n * @see ShapeOps\n *\n * @param element target shape\n * @param ownerDocument document for create element\n * @return the newly created `<path>` element\n */\nconst shapeToPathArray = (element: ShapeTypes | ShapeOps, ownerDocument?: Document) => {\n  const doc = ownerDocument || document;\n  const win = doc.defaultView || /* istanbul ignore next */ window;\n  const supportedShapes = Object.keys(shapeParams) as (keyof ShapeParams)[];\n  const targetIsElement = element instanceof win.SVGElement;\n  const tagName = targetIsElement ? element.tagName : null;\n\n  if (tagName && [...supportedShapes, 'path'].every(s => tagName !== s)) {\n    throw TypeError(`${error}: \"${tagName}\" is not SVGElement`);\n  }\n\n  const type = (targetIsElement ? tagName : element.type) as ShapeOps['type'];\n  const shapeAttrs = shapeParams[type] as string[];\n  const config = { type } as Record<string, string>;\n\n  if (targetIsElement) {\n    shapeAttrs.forEach(p => {\n      config[p] = element.getAttribute(p) as string;\n    });\n  } else {\n    Object.assign(config, element);\n  }\n\n  // set d\n  let pathArray = [] as unknown as PathArray;\n\n  /* istanbul ignore else */\n  if (type === 'circle') pathArray = getCirclePath(config as unknown as CircleAttr);\n  else if (type === 'ellipse') pathArray = getEllipsePath(config as unknown as EllipseAttr);\n  else if (['polyline', 'polygon'].includes(type)) pathArray = getPolyPath(config as unknown as PolyAttr);\n  else if (type === 'rect') pathArray = getRectanglePath(config as unknown as RectAttr);\n  else if (type === 'line') pathArray = getLinePath(config as unknown as LineAttr);\n  else if (['glyph', 'path'].includes(type)) {\n    pathArray = parsePathString(\n      targetIsElement\n        ? element.getAttribute('d') || /* istanbul ignore next @preserve */ ''\n        : (element as GlyphAttr).d || '',\n    );\n  }\n\n  // replace target element\n  if (isPathArray(pathArray) && pathArray.length) {\n    return pathArray;\n  }\n  return false;\n};\nexport default shapeToPathArray;\n","import type { PathArray } from 'src/types';\nimport defaultOptions from '../options/options';\n\n/**\n * Rounds the values of a `pathArray` instance to\n * a specified amount of decimals and returns it.\n *\n * @param path the source `pathArray`\n * @param roundOption the amount of decimals to round numbers to\n * @returns the resulted `pathArray` with rounded values\n */\nconst roundPath = (path: PathArray, roundOption?: number | 'off'): PathArray => {\n  let { round } = defaultOptions;\n  if (roundOption === 'off' || round === 'off') return [...path];\n  // allow for ZERO decimals\n  round = typeof roundOption === 'number' && roundOption >= 0 ? roundOption : round;\n  // to round values to the power\n  // the `round` value must be integer\n  const pow = typeof round === 'number' && round >= 1 ? 10 ** round : 1;\n\n  return path.map(pi => {\n    const values = pi\n      .slice(1)\n      .map(Number)\n      .map(n => (round ? Math.round(n * pow) / pow : Math.round(n)));\n    return [pi[0], ...values];\n  }) as PathArray;\n};\nexport default roundPath;\n","import type { PathArray } from '../types';\nimport roundPath from '../process/roundPath';\n\n/**\n * Returns a valid `d` attribute string value created\n * by rounding values and concatenating the `pathArray` segments.\n *\n * @param path the `pathArray` object\n * @param round amount of decimals to round values to\n * @returns the concatenated path string\n */\nconst pathToString = (path: PathArray, round?: number | 'off'): string => {\n  return roundPath(path, round)\n    .map(x => x[0] + x.slice(1).join(' '))\n    .join('');\n};\nexport default pathToString;\n","import type { ShapeParams } from '../interface';\nimport type { ShapeOps, ShapeTypes } from '../types';\nimport pathToString from '../convert/pathToString';\nimport defaultOptions from '../options/options';\nimport error from '../parser/error';\nimport isValidPath from './isValidPath';\nimport shapeToPathArray from './shapeToPathArray';\nimport shapeParams from './shapeParams';\n\n/**\n * Returns a new `<path>` element created from attributes of a `<line>`, `<polyline>`,\n * `<polygon>`, `<rect>`, `<ellipse>`, `<circle>` or `<glyph>`. If `replace` parameter\n * is `true`, it will replace the target. The default `ownerDocument` is your current\n * `document` browser page, if you want to use in server-side using `jsdom`, you can\n * pass the `jsdom` `document` to `ownDocument`.\n *\n * It can also work with an options object, see the type below\n *\n * @see ShapeOps\n *\n * The newly created `<path>` element keeps all non-specific\n * attributes like `class`, `fill`, etc.\n *\n * @param element target shape\n * @param replace option to replace target\n * @param ownerDocument document for create element\n * @return the newly created `<path>` element\n */\nconst shapeToPath = (\n  element: ShapeTypes | ShapeOps,\n  replace?: boolean,\n  ownerDocument?: Document,\n): SVGPathElement | false => {\n  const doc = ownerDocument || document;\n  const win = doc.defaultView || /* istanbul ignore next */ window;\n  const supportedShapes = Object.keys(shapeParams) as (keyof ShapeParams)[];\n  const targetIsElement = element instanceof win.SVGElement;\n  const tagName = targetIsElement ? element.tagName : null;\n\n  if (tagName === 'path') throw TypeError(`${error}: \"${tagName}\" is already SVGPathElement`);\n  if (tagName && supportedShapes.every(s => tagName !== s)) throw TypeError(`${error}: \"${tagName}\" is not SVGElement`);\n\n  const path = doc.createElementNS('http://www.w3.org/2000/svg', 'path');\n  const type = (targetIsElement ? tagName : element.type) as ShapeOps['type'];\n  const shapeAttrs = shapeParams[type] as string[];\n  const config = { type } as Record<string, string>;\n\n  // set d\n  const round = defaultOptions.round as number;\n  const pathArray = shapeToPathArray(element, doc);\n  const description = pathArray && pathArray.length ? pathToString(pathArray, round) : '';\n\n  if (targetIsElement) {\n    shapeAttrs.forEach(p => {\n      config[p] = element.getAttribute(p) as string;\n    });\n    // set no-specific shape attributes: fill, stroke, etc\n    Object.values(element.attributes).forEach(({ name, value }) => {\n      if (!shapeAttrs.includes(name)) path.setAttribute(name, value);\n    });\n  } else {\n    Object.assign(config, element);\n    // set no-specific shape attributes: fill, stroke, etc\n    Object.keys(config).forEach(k => {\n      if (!shapeAttrs.includes(k) && k !== 'type') {\n        path.setAttribute(\n          k.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`),\n          config[k],\n        );\n      }\n    });\n  }\n\n  // replace target element\n  if (isValidPath(description)) {\n    path.setAttribute('d', description);\n    if (replace && targetIsElement) {\n      element.before(path, element);\n      element.remove();\n    }\n    return path;\n  }\n  return false;\n};\n\nexport default shapeToPath;\n","import type { PathArray } from '../types';\n\n/**\n * Split a path into an `Array` of sub-path strings.\n *\n * In the process, values are converted to absolute\n * for visual consistency.\n *\n * @param pathInput the source `pathArray`\n * @return {SVGPath.pathArray[]} an array with all sub-path strings\n */\nconst splitPath = (pathInput: PathArray): PathArray[] => {\n  const composite = [] as PathArray[];\n  let path: PathArray;\n  let pi = -1;\n\n  pathInput.forEach(seg => {\n    if (seg[0] === 'M') {\n      path = [seg];\n      pi += 1;\n    } else {\n      path.push(seg);\n    }\n    composite[pi] = path;\n  });\n\n  return composite;\n};\nexport default splitPath;\n","import CSSMatrix from '@thednp/dommatrix';\n// import type { TransformObject } from '../interface';\nimport type { TransformObjectValues } from '../types';\n\n/**\n * Returns a transformation matrix to apply to `<path>` elements.\n *\n * @see TransformObjectValues\n *\n * @param transform the `transformObject`\n * @returns a new transformation matrix\n */\nconst getSVGMatrix = (transform: TransformObjectValues): CSSMatrix => {\n  let matrix = new CSSMatrix();\n  const { origin } = transform;\n  const [originX, originY] = origin as [number, number, number];\n  const { translate } = transform;\n  const { rotate } = transform;\n  const { skew } = transform;\n  const { scale } = transform;\n\n  // set translate\n  if (\n    Array.isArray(translate) &&\n    translate.length >= 2 &&\n    translate.every(x => !Number.isNaN(+x)) &&\n    translate.some(x => x !== 0)\n  ) {\n    matrix = matrix.translate(...(translate as [number, number, number?]));\n  } else if (typeof translate === 'number' && !Number.isNaN(translate)) {\n    matrix = matrix.translate(translate);\n  }\n\n  if (rotate || skew || scale) {\n    // set SVG transform-origin, always defined\n    matrix = matrix.translate(originX, originY);\n\n    // set rotation\n    if (\n      Array.isArray(rotate) &&\n      rotate.length >= 2 &&\n      rotate.every(x => !Number.isNaN(+x)) &&\n      rotate.some(x => x !== 0)\n    ) {\n      matrix = matrix.rotate(...(rotate as [number, number, number?]));\n    } else if (typeof rotate === 'number' && !Number.isNaN(rotate)) {\n      matrix = matrix.rotate(rotate);\n    }\n\n    // set skew(s)\n    if (Array.isArray(skew) && skew.length === 2 && skew.every(x => !Number.isNaN(+x)) && skew.some(x => x !== 0)) {\n      matrix = skew[0] ? matrix.skewX(skew[0]) : matrix;\n      matrix = skew[1] ? matrix.skewY(skew[1]) : matrix;\n    } else if (typeof skew === 'number' && !Number.isNaN(skew)) {\n      matrix = matrix.skewX(skew);\n    }\n\n    // set scale\n    if (Array.isArray(scale) && scale.length >= 2 && scale.every(x => !Number.isNaN(+x)) && scale.some(x => x !== 1)) {\n      matrix = matrix.scale(...(scale as [number, number, number?]));\n    } else if (typeof scale === 'number' && !Number.isNaN(scale)) {\n      matrix = matrix.scale(scale);\n    }\n    // set SVG transform-origin\n    matrix = matrix.translate(-originX, -originY);\n  }\n\n  return matrix;\n};\nexport default getSVGMatrix;\n","import type {\n  aSegment,\n  hSegment,\n  PathArray,\n  RelativeArray,\n  RelativeCommand,\n  RelativeSegment,\n  vSegment,\n} from '../types';\nimport parsePathString from '../parser/parsePathString';\nimport isRelativeArray from '../util/isRelativeArray';\n\n/**\n * Parses a path string value or object and returns an array\n * of segments, all converted to relative values.\n *\n * @param pathInput the path string | object\n * @returns the resulted `pathArray` with relative values\n */\nconst pathToRelative = (pathInput: string | PathArray): RelativeArray => {\n  /* istanbul ignore else */\n  if (isRelativeArray(pathInput)) {\n    return pathInput.slice(0) as RelativeArray;\n  }\n\n  const path = parsePathString(pathInput);\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n\n  return path.map(segment => {\n    const values = segment.slice(1).map(Number);\n    const [pathCommand] = segment;\n    const relativeCommand = pathCommand.toLowerCase() as RelativeCommand;\n\n    if (pathCommand === 'M') {\n      [x, y] = values;\n      mx = x;\n      my = y;\n      return ['M', x, y];\n    }\n\n    let relativeSegment = [];\n\n    if (pathCommand !== relativeCommand) {\n      if (relativeCommand === 'a') {\n        relativeSegment = [\n          relativeCommand,\n          values[0],\n          values[1],\n          values[2],\n          values[3],\n          values[4],\n          values[5] - x,\n          values[6] - y,\n        ] as aSegment;\n      } else if (relativeCommand === 'v') {\n        relativeSegment = [relativeCommand, values[0] - y] as vSegment;\n      } else if (relativeCommand === 'h') {\n        relativeSegment = [relativeCommand, values[0] - x] as hSegment;\n      } else {\n        // use brakets for `eslint: no-case-declaration`\n        // https://stackoverflow.com/a/50753272/803358\n        const relValues = values.map((n, j) => n - (j % 2 ? y : x));\n        relativeSegment = [relativeCommand, ...relValues] as RelativeSegment;\n      }\n    } else {\n      if (pathCommand === 'm') {\n        mx = values[0] + x;\n        my = values[1] + y;\n      }\n      relativeSegment = [relativeCommand, ...values] as RelativeSegment;\n    }\n\n    const segLength = relativeSegment.length;\n    if (relativeCommand === 'z') {\n      x = mx;\n      y = my;\n    } else if (relativeCommand === 'h') {\n      x += relativeSegment[1] as number;\n    } else if (relativeCommand === 'v') {\n      y += relativeSegment[1] as number;\n    } else {\n      x += relativeSegment[segLength - 2] as number;\n      y += relativeSegment[segLength - 1] as number;\n    }\n\n    return relativeSegment as typeof segment;\n  }) as RelativeArray;\n};\nexport default pathToRelative;\n","import type { ParserParams } from 'src/interface';\nimport type {\n  AbsoluteSegment,\n  HSegment,\n  NormalSegment,\n  PathCommand,\n  ShortSegment,\n  SSegment,\n  TSegment,\n  VSegment,\n  ZSegment,\n} from '../types';\n\n/**\n * Shorten a single segment of a `pathArray` object.\n *\n * @param segment the `absoluteSegment` object\n * @param normalSegment the `normalSegment` object\n * @param params the coordinates of the previous segment\n * @param prevCommand the path command of the previous segment\n * @returns the shortened segment\n */\nconst shortenSegment = (\n  segment: AbsoluteSegment,\n  normalSegment: NormalSegment,\n  params: ParserParams,\n  prevCommand: PathCommand,\n): ShortSegment => {\n  const [pathCommand] = segment;\n  const round4 = (n: number) => Math.round(n * 10 ** 4) / 10 ** 4;\n  const segmentValues = segment.slice(1).map(n => +n);\n  const normalValues = normalSegment.slice(1).map(n => +n);\n  const { x1: px1, y1: py1, x2: px2, y2: py2, x: px, y: py } = params;\n  let result = segment;\n  const [x, y] = normalValues.slice(-2);\n\n  if (!'TQ'.includes(pathCommand)) {\n    // optional but good to be cautious\n    params.qx = null;\n    params.qy = null;\n  }\n\n  if (['V', 'H', 'S', 'T', 'Z'].includes(pathCommand)) {\n    result = [pathCommand, ...segmentValues] as VSegment | HSegment | SSegment | TSegment | ZSegment;\n  } else if (pathCommand === 'L') {\n    if (round4(px) === round4(x)) {\n      result = ['V', y];\n    } else if (round4(py) === round4(y)) {\n      result = ['H', x];\n    }\n  } else if (pathCommand === 'C') {\n    const [x1, y1] = normalValues;\n\n    if (\n      'CS'.includes(prevCommand) &&\n      ((round4(x1) === round4(px1 * 2 - px2) && round4(y1) === round4(py1 * 2 - py2)) ||\n        (round4(px1) === round4(px2 * 2 - px) && round4(py1) === round4(py2 * 2 - py)))\n    ) {\n      result = ['S', ...normalValues.slice(-4)] as SSegment;\n    }\n    params.x1 = x1;\n    params.y1 = y1;\n  } else if (pathCommand === 'Q') {\n    const [qx, qy] = normalValues;\n    params.qx = qx;\n    params.qy = qy;\n\n    if (\n      'QT'.includes(prevCommand) &&\n      ((round4(qx) === round4(px1 * 2 - px2) && round4(qy) === round4(py1 * 2 - py2)) ||\n        (round4(px1) === round4(px2 * 2 - px) && round4(py1) === round4(py2 * 2 - py)))\n    ) {\n      result = ['T', ...normalValues.slice(-2)] as TSegment;\n    }\n  }\n\n  return result as ShortSegment;\n};\nexport default shortenSegment;\n","import roundPath from './roundPath';\nimport pathToAbsolute from '../convert/pathToAbsolute';\nimport pathToRelative from '../convert/pathToRelative';\nimport shortenSegment from './shortenSegment';\nimport paramsParser from '../parser/paramsParser';\nimport normalizePath from './normalizePath';\nimport type { PathSegment, HSegment, PathArray, VSegment, PathCommand, AbsoluteSegment } from '../types';\n\n/**\n * Optimizes a `pathArray` object:\n * * convert segments to shorthand if possible\n * * select shortest segments from absolute and relative `pathArray`s\n *\n * @param pathInput a string or `pathArray`\n * @param round the amount of decimals to round values to\n * @returns the optimized `pathArray`\n */\nconst optimizePath = (pathInput: PathArray, round: 'off' | number): PathArray => {\n  const path = pathToAbsolute(pathInput);\n  const normalPath = normalizePath(path);\n  const params = { ...paramsParser };\n  const allPathCommands = [] as PathCommand[];\n  const ii = path.length;\n  let pathCommand = '' as PathCommand;\n  let prevCommand = '' as PathCommand;\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n\n  for (let i = 0; i < ii; i += 1) {\n    [pathCommand] = path[i];\n\n    // Save current path command\n    allPathCommands[i] = pathCommand;\n    // Get previous path command for `shortenSegment`\n    if (i) prevCommand = allPathCommands[i - 1];\n    path[i] = shortenSegment(path[i], normalPath[i], params, prevCommand) as AbsoluteSegment;\n\n    const segment = path[i];\n    const seglen = segment.length;\n\n    // update C, S, Q, T specific params\n    params.x1 = +segment[seglen - 2];\n    params.y1 = +segment[seglen - 1];\n    params.x2 = +segment[seglen - 4] || params.x1;\n    params.y2 = +segment[seglen - 3] || params.y1;\n\n    // update x, y params\n    switch (pathCommand) {\n      case 'Z':\n        x = mx;\n        y = my;\n        break;\n      case 'H':\n        [, x] = segment as HSegment;\n        break;\n      case 'V':\n        [, y] = segment as VSegment;\n        break;\n      default:\n        [x, y] = segment.slice(-2).map(Number);\n\n        if (pathCommand === 'M') {\n          mx = x;\n          my = y;\n        }\n    }\n    params.x = x;\n    params.y = y;\n  }\n\n  const absolutePath = roundPath(path, round);\n  const relativePath = roundPath(pathToRelative(path), round);\n\n  return absolutePath.map((a: PathSegment, i: number) => {\n    if (i) {\n      return a.join('').length < relativePath[i].join('').length ? a : relativePath[i];\n    }\n    return a;\n  }) as PathArray;\n};\nexport default optimizePath;\n","import type { CurveArray } from '../types';\n\n/**\n * Reverses all segments of a `pathArray`\n * which consists of only C (cubic-bezier) path commands.\n *\n * @param path the source `pathArray`\n * @returns the reversed `pathArray`\n */\nconst reverseCurve = (path: CurveArray): CurveArray => {\n  const rotatedCurve = path\n    .slice(1)\n    .map((x, i, curveOnly) =>\n      !i ? [...path[0].slice(1), ...x.slice(1)] : [...curveOnly[i - 1].slice(-2), ...x.slice(1)],\n    )\n    .map(x => x.map((_, i) => x[x.length - i - 2 * (1 - (i % 2))]))\n    .reverse();\n\n  return [['M', ...rotatedCurve[0].slice(0, 2)], ...rotatedCurve.map(x => ['C', ...x.slice(2)])] as CurveArray;\n};\nexport default reverseCurve;\n","import type {\n  ASegment,\n  CSegment,\n  HSegment,\n  MSegment,\n  PathArray,\n  PathSegment,\n  QSegment,\n  SSegment,\n  TSegment,\n  VSegment,\n} from 'src/types';\nimport pathToAbsolute from '../convert/pathToAbsolute';\nimport normalizePath from './normalizePath';\n\n/**\n * Reverses all segments of a `pathArray` and returns a new `pathArray` instance.\n *\n * @param pathInput the source `pathArray`\n * @returns the reversed `pathArray`\n */\nconst reversePath = (pathInput: PathArray): PathArray => {\n  const absolutePath = pathToAbsolute(pathInput);\n  const isClosed = absolutePath.slice(-1)[0][0] === 'Z';\n\n  const reversedPath = normalizePath(absolutePath)\n    .map((segment, i) => {\n      const [x, y] = segment.slice(-2).map(Number);\n      return {\n        seg: absolutePath[i], // absolute\n        n: segment, // normalized\n        c: absolutePath[i][0], // pathCommand\n        x, // x\n        y, // y\n      };\n    })\n    .map((seg, i, path) => {\n      const segment = seg.seg;\n      const data = seg.n;\n      const prevSeg = i && path[i - 1];\n      const nextSeg = path[i + 1];\n      const pathCommand = seg.c;\n      const pLen = path.length;\n      const x = i ? path[i - 1].x : path[pLen - 1].x;\n      const y = i ? path[i - 1].y : path[pLen - 1].y;\n      let result = [];\n\n      switch (pathCommand) {\n        case 'M':\n          result = (isClosed ? ['Z'] : [pathCommand, x, y]) as PathSegment;\n          break;\n        case 'A':\n          result = [pathCommand, ...segment.slice(1, -3), segment[5] === 1 ? 0 : 1, x, y] as ASegment;\n          break;\n        case 'C':\n          if (nextSeg && nextSeg.c === 'S') {\n            result = ['S', segment[1], segment[2], x, y] as SSegment;\n          } else {\n            result = [pathCommand, segment[3], segment[4], segment[1], segment[2], x, y] as CSegment;\n          }\n          break;\n        case 'S':\n          if (prevSeg && 'CS'.includes(prevSeg.c) && (!nextSeg || nextSeg.c !== 'S')) {\n            result = ['C', data[3], data[4], data[1], data[2], x, y] as CSegment;\n          } else {\n            result = [pathCommand, data[1], data[2], x, y] as SSegment;\n          }\n          break;\n        case 'Q':\n          if (nextSeg && nextSeg.c === 'T') {\n            result = ['T', x, y] as TSegment;\n          } else {\n            result = [pathCommand, ...segment.slice(1, -2), x, y] as QSegment;\n          }\n          break;\n        case 'T':\n          if (prevSeg && 'QT'.includes(prevSeg.c) && (!nextSeg || nextSeg.c !== 'T')) {\n            result = ['Q', data[1], data[2], x, y] as QSegment;\n          } else {\n            result = [pathCommand, x, y] as TSegment;\n          }\n          break;\n        case 'Z':\n          result = ['M', x, y] as MSegment;\n          break;\n        case 'H':\n          result = [pathCommand, x] as HSegment;\n          break;\n        case 'V':\n          result = [pathCommand, y] as VSegment;\n          break;\n        default:\n          result = [pathCommand, ...segment.slice(1, -2), x, y] as PathSegment;\n      }\n\n      return result;\n    });\n\n  return (isClosed ? reversedPath.reverse() : [reversedPath[0], ...reversedPath.slice(1).reverse()]) as PathArray;\n};\nexport default reversePath;\n","import CSSMatrix from '@thednp/dommatrix';\n\n/**\n * Transforms a specified point using a matrix, returning a new\n * Tuple *Object* comprising of the transformed point.\n * Neither the matrix nor the original point are altered.\n *\n * @copyright thednp © 2021\n *\n * @param cssm CSSMatrix instance\n * @param v Tuple\n * @return the resulting Tuple\n */\nconst translatePoint = (cssm: CSSMatrix, v: [number, number, number, number]): [number, number, number, number] => {\n  let m = CSSMatrix.Translate(...(v.slice(0, -1) as [number, number, number]));\n\n  [, , , m.m44] = v;\n  m = cssm.multiply(m);\n\n  return [m.m41, m.m42, m.m43, m.m44];\n};\n\n/**\n * Returns the [x,y] projected coordinates for a given an [x,y] point\n * and an [x,y,z] perspective origin point.\n *\n * Equation found here =>\n * http://en.wikipedia.org/wiki/3D_projection#Diagram\n * Details =>\n * https://stackoverflow.com/questions/23792505/predicted-rendering-of-css-3d-transformed-pixel\n *\n * @param m the transformation matrix\n * @param point2D the initial [x,y] coordinates\n * @param origin the [x,y,z] transform origin\n * @returns the projected [x,y] coordinates\n */\nconst projection2d = (m: CSSMatrix, point2D: [number, number], origin: [number, number, number]): [number, number] => {\n  const [originX, originY, originZ] = origin;\n  const [x, y, z] = translatePoint(m, [...point2D, 0, 1]);\n\n  const relativePositionX = x - originX;\n  const relativePositionY = y - originY;\n  const relativePositionZ = z - originZ;\n\n  return [\n    // protect against division by ZERO\n    relativePositionX * (Math.abs(originZ) / Math.abs(relativePositionZ) || 1) + originX,\n    relativePositionY * (Math.abs(originZ) / Math.abs(relativePositionZ) || 1) + originY,\n  ];\n};\nexport default projection2d;\n","import type { PathArray, PathCommand, PathSegment } from '../types';\nimport isNormalizedArray from '../util/isNormalizedArray';\nimport segmentToCubic from './segmentToCubic';\nimport paramsParser from '../parser/paramsParser';\nimport normalizePath from './normalizePath';\nimport fixArc from './fixArc';\nimport isAbsoluteArray from '../util/isAbsoluteArray';\nimport pathToAbsolute from '../convert/pathToAbsolute';\n\nconst replaceArc = (pathInput: PathArray | string): PathArray => {\n  const absolutePath = isAbsoluteArray(pathInput) ? pathInput : pathToAbsolute(pathInput);\n  const normalizedPath = isNormalizedArray(absolutePath) ? absolutePath : normalizePath(absolutePath);\n  const params = { ...paramsParser };\n  const allPathCommands = [] as PathCommand[]; // needed for arc to curve transformation\n  let segment = [] as unknown as PathSegment;\n  let seglen = 0;\n  let pathCommand = '';\n  const resultedPath = [] as unknown as PathArray;\n  let i = 0;\n  let ii = absolutePath.length;\n\n  for (i = 0; i < ii; i += 1) {\n    /* istanbul ignore else @preserve */\n    if (absolutePath[i]) [pathCommand] = absolutePath[i];\n    allPathCommands[i] = pathCommand as PathCommand;\n\n    /* istanbul ignore else @preserve */\n    if (pathCommand === 'A') {\n      segment = segmentToCubic(normalizedPath[i], params);\n\n      absolutePath[i] = segmentToCubic(normalizedPath[i], params);\n      fixArc(absolutePath, allPathCommands, i);\n\n      normalizedPath[i] = segmentToCubic(normalizedPath[i], params);\n      fixArc(normalizedPath, allPathCommands, i);\n      ii = Math.max(absolutePath.length, normalizedPath.length);\n    }\n\n    segment = normalizedPath[i];\n    seglen = segment.length;\n\n    params.x1 = +segment[seglen - 2];\n    params.y1 = +segment[seglen - 1];\n    params.x2 = +segment[seglen - 4] || params.x1;\n    params.y2 = +segment[seglen - 3] || params.y1;\n\n    resultedPath.push(absolutePath[i]);\n  }\n  return resultedPath;\n};\n\nexport default replaceArc;\n","import normalizePath from './normalizePath';\n// import pathToAbsolute from '../convert/pathToAbsolute';\n// import segmentToCubic from './segmentToCubic';\n// import fixArc from './fixArc';\nimport getSVGMatrix from './getSVGMatrix';\nimport projection2d from './projection2d';\nimport paramsParser from '../parser/paramsParser';\nimport replaceArc from './replaceArc';\nimport defaultOptions from '../options/options';\nimport type { AbsoluteArray, PathArray, TransformObjectValues } from '../types';\nimport type { PathTransform, TransformObject } from '../interface';\n\n/**\n * Apply a 2D / 3D transformation to a `pathArray` instance.\n *\n * Since *SVGElement* doesn't support 3D transformation, this function\n * creates a 2D projection of the <path> element.\n *\n * @param path the `pathArray` to apply transformation\n * @param transform the transform functions `Object`\n * @returns the resulted `pathArray`\n */\nconst transformPath = (path: string | PathArray, transform?: Partial<TransformObject>): PathArray => {\n  let x = 0;\n  let y = 0;\n  let i;\n  let j;\n  let ii;\n  let jj;\n  let lx;\n  let ly;\n  // REPLACE Arc path commands with Cubic Beziers\n  // we don't have any scripting know-how on 3d ellipse transformation\n  // Arc segments don't work with 3D transformations or skews\n  const absolutePath = replaceArc(path);\n  const transformProps = transform && Object.keys(transform);\n\n  // when used as a static method, invalidate somehow\n  if (!transform || (transformProps && !transformProps.length)) return absolutePath.slice(0) as PathArray;\n\n  const normalizedPath = normalizePath(absolutePath);\n  // transform origin is extremely important\n  if (!transform.origin) {\n    const { origin: defaultOrigin } = defaultOptions;\n    Object.assign(transform, { origin: defaultOrigin });\n  }\n  const matrixInstance = getSVGMatrix(transform as TransformObjectValues);\n  const { origin } = transform;\n  const params = { ...paramsParser };\n  let segment = [];\n  let seglen = 0;\n  let pathCommand = '';\n  const transformedPath = [] as PathTransform[];\n\n  if (!matrixInstance.isIdentity) {\n    for (i = 0, ii = absolutePath.length; i < ii; i += 1) {\n      segment = normalizedPath[i];\n      seglen = segment.length;\n\n      params.x1 = +segment[seglen - 2];\n      params.y1 = +segment[seglen - 1];\n      params.x2 = +segment[seglen - 4] || params.x1;\n      params.y2 = +segment[seglen - 3] || params.y1;\n\n      const result = {\n        s: absolutePath[i],\n        c: absolutePath[i][0],\n        x: params.x1,\n        y: params.y1,\n      };\n\n      transformedPath.push(result);\n    }\n\n    return transformedPath.map(seg => {\n      pathCommand = seg.c;\n      segment = seg.s;\n      if (pathCommand === 'L' || pathCommand === 'H' || pathCommand === 'V') {\n        [lx, ly] = projection2d(matrixInstance, [seg.x, seg.y], origin as [number, number, number]);\n\n        /* istanbul ignore else @preserve */\n        if (x !== lx && y !== ly) {\n          segment = ['L', lx, ly];\n        } else if (y === ly) {\n          segment = ['H', lx];\n        } else if (x === lx) {\n          segment = ['V', ly];\n        }\n\n        // now update x and y\n        x = lx;\n        y = ly;\n\n        return segment;\n      } else {\n        for (j = 1, jj = segment.length; j < jj; j += 2) {\n          [x, y] = projection2d(matrixInstance, [+segment[j], +segment[j + 1]], origin as [number, number, number]);\n          segment[j] = x;\n          segment[j + 1] = y;\n        }\n\n        return segment;\n      }\n    }) as PathArray;\n  }\n  return absolutePath.slice(0) as AbsoluteArray;\n};\nexport default transformPath;\n","import midPoint from '../math/midPoint';\nimport type { CubicSegment } from '../types';\n\n/**\n * Split a cubic-bezier segment into two.\n *\n * @param pts the cubic-bezier parameters\n * @return two new cubic-bezier segments\n */\nconst splitCubic = (pts: number[] /* , ratio */): [CubicSegment, CubicSegment] => {\n  const t = /* ratio || */ 0.5;\n  const p0 = pts.slice(0, 2) as [number, number];\n  const p1 = pts.slice(2, 4) as [number, number];\n  const p2 = pts.slice(4, 6) as [number, number];\n  const p3 = pts.slice(6, 8) as [number, number];\n  const p4 = midPoint(p0, p1, t);\n  const p5 = midPoint(p1, p2, t);\n  const p6 = midPoint(p2, p3, t);\n  const p7 = midPoint(p4, p5, t);\n  const p8 = midPoint(p5, p6, t);\n  const p9 = midPoint(p7, p8, t);\n\n  return [\n    ['C', ...p4, ...p7, ...p9],\n    ['C', ...p8, ...p6, ...p3],\n  ];\n};\nexport default splitCubic;\n","import { PathArray, TransformObjectValues } from './types';\nimport type { Options, TransformEntries, TransformObject } from './interface';\nexport * from './types';\nexport * from './interface';\nimport defaultOptions from './options/options';\n\nimport error from './parser/error';\nimport parsePathString from './parser/parsePathString';\n\nimport polygonArea from './math/polygonArea';\nimport polygonLength from './math/polygonLength';\n\nimport CSSMatrix from '@thednp/dommatrix';\nimport getPathBBox from './util/getPathBBox';\nimport getPathArea from './util/getPathArea';\nimport getTotalLength from './util/getTotalLength';\nimport getDrawDirection from './util/getDrawDirection';\nimport getPointAtLength from './util/getPointAtLength';\nimport pathFactory from './util/pathFactory';\n\nimport getPropertiesAtLength from './util/getPropertiesAtLength';\nimport getPropertiesAtPoint from './util/getPropertiesAtPoint';\nimport getClosestPoint from './util/getClosestPoint';\nimport getSegmentOfPoint from './util/getSegmentOfPoint';\nimport getSegmentAtLength from './util/getSegmentAtLength';\nimport isPointInStroke from './util/isPointInStroke';\n\nimport isValidPath from './util/isValidPath';\nimport isPathArray from './util/isPathArray';\nimport isAbsoluteArray from './util/isAbsoluteArray';\nimport isRelativeArray from './util/isRelativeArray';\nimport isCurveArray from './util/isCurveArray';\nimport isNormalizedArray from './util/isNormalizedArray';\nimport shapeToPathArray from './util/shapeToPathArray';\nimport shapeToPath from './util/shapeToPath';\n\nimport roundPath from './process/roundPath';\nimport splitPath from './process/splitPath';\nimport getSVGMatrix from './process/getSVGMatrix';\nimport optimizePath from './process/optimizePath';\nimport reverseCurve from './process/reverseCurve';\nimport reversePath from './process/reversePath';\nimport normalizePath from './process/normalizePath';\nimport transformPath from './process/transformPath';\nimport splitCubic from './process/splitCubic';\nimport replaceArc from './process/replaceArc';\n\nimport pathToAbsolute from './convert/pathToAbsolute';\nimport pathToRelative from './convert/pathToRelative';\nimport pathToCurve from './convert/pathToCurve';\nimport pathToString from './convert/pathToString';\n\n/**\n * Creates a new SVGPathCommander instance with the following properties:\n * * segments: `pathArray`\n * * round: number\n * * origin: [number, number, number?]\n *\n * @class\n * @author thednp <https://github.com/thednp/svg-path-commander>\n * @returns a new SVGPathCommander instance\n */\nclass SVGPathCommander {\n  // bring main utilities to front\n  public static CSSMatrix = CSSMatrix;\n  public static getSVGMatrix = getSVGMatrix;\n  public static getPathBBox = getPathBBox;\n  public static getPathArea = getPathArea;\n  public static getTotalLength = getTotalLength;\n  public static getDrawDirection = getDrawDirection;\n  public static getPointAtLength = getPointAtLength;\n  public static pathFactory = pathFactory;\n  public static getPropertiesAtLength = getPropertiesAtLength;\n  public static getPropertiesAtPoint = getPropertiesAtPoint;\n  public static polygonLength = polygonLength;\n  public static polygonArea = polygonArea;\n  public static getClosestPoint = getClosestPoint;\n  public static getSegmentOfPoint = getSegmentOfPoint;\n  public static getSegmentAtLength = getSegmentAtLength;\n  public static isPointInStroke = isPointInStroke;\n  public static isValidPath = isValidPath;\n  public static isPathArray = isPathArray;\n  public static isAbsoluteArray = isAbsoluteArray;\n  public static isRelativeArray = isRelativeArray;\n  public static isCurveArray = isCurveArray;\n  public static isNormalizedArray = isNormalizedArray;\n  public static shapeToPath = shapeToPath;\n  public static shapeToPathArray = shapeToPathArray;\n  public static parsePathString = parsePathString;\n  public static roundPath = roundPath;\n  public static splitPath = splitPath;\n  public static splitCubic = splitCubic;\n  public static replaceArc = replaceArc;\n  public static optimizePath = optimizePath;\n  public static reverseCurve = reverseCurve;\n  public static reversePath = reversePath;\n  public static normalizePath = normalizePath;\n  public static transformPath = transformPath;\n  public static pathToAbsolute = pathToAbsolute;\n  public static pathToRelative = pathToRelative;\n  public static pathToCurve = pathToCurve;\n  public static pathToString = pathToString;\n  // declare class properties\n  declare segments: PathArray;\n  declare round: number | 'off';\n  declare origin: [number, number, number];\n\n  /**\n   * @constructor\n   * @param pathValue the path string\n   * @param config instance options\n   */\n  constructor(pathValue: string, config?: Partial<Options>) {\n    const instanceOptions = config || {};\n    const undefPath = typeof pathValue === 'undefined';\n\n    if (undefPath || !pathValue.length) {\n      throw TypeError(`${error}: \"pathValue\" is ${undefPath ? 'undefined' : 'empty'}`);\n    }\n\n    const segments = parsePathString(pathValue);\n    this.segments = segments;\n    const { width, height, cx, cy, cz } = this.bbox;\n\n    // set instance options.round\n    const { round: roundOption, origin: originOption } = instanceOptions;\n    let round: number | 'off';\n\n    if (roundOption === 'auto') {\n      const pathScale = `${Math.floor(Math.max(width, height))}`.length;\n      round = pathScale >= 4 ? 0 : 4 - pathScale;\n    } else if (Number.isInteger(roundOption) || roundOption === 'off') {\n      round = roundOption as number | 'off';\n    } else {\n      round = defaultOptions.round as number;\n    }\n\n    // set instance options.origin\n    // the SVGPathCommander class will always override the default origin\n    let origin = [cx, cy, cz] as [number, number, number];\n    /* istanbul ignore else @preserve */\n    if (Array.isArray(originOption) && originOption.length >= 2) {\n      const [originX, originY, originZ] = originOption.map(Number);\n      origin = [\n        !Number.isNaN(originX) ? originX : cx,\n        !Number.isNaN(originY) ? originY : cy,\n        !Number.isNaN(originZ) ? originZ : cz,\n      ];\n    }\n\n    this.round = round;\n    this.origin = origin;\n\n    return this;\n  }\n  get bbox() {\n    return getPathBBox(this.segments);\n  }\n  get length() {\n    return getTotalLength(this.segments);\n  }\n\n  /**\n   * Returns the path bounding box, equivalent to native `path.getBBox()`.\n   *\n   * @public\n   * @returns the pathBBox\n   */\n  getBBox() {\n    return this.bbox;\n  }\n\n  /**\n   * Returns the total path length, equivalent to native `path.getTotalLength()`.\n   *\n   * @public\n   * @returns the path total length\n   */\n  getTotalLength() {\n    return this.length;\n  }\n\n  /**\n   * Returns an `{x,y}` point in the path stroke at a given length,\n   * equivalent to the native `path.getPointAtLength()`.\n   *\n   * @public\n   * @param length the length\n   * @returns the requested point\n   */\n  getPointAtLength(length: number) {\n    return getPointAtLength(this.segments, length);\n  }\n\n  /**\n   * Convert path to absolute values\n   *\n   * @public\n   */\n  toAbsolute() {\n    const { segments } = this;\n    this.segments = pathToAbsolute(segments);\n    return this;\n  }\n\n  /**\n   * Convert path to relative values\n   *\n   * @public\n   */\n  toRelative() {\n    const { segments } = this;\n    this.segments = pathToRelative(segments);\n    return this;\n  }\n\n  /**\n   * Convert path to cubic-bezier values. In addition, un-necessary `Z`\n   * segment is removed if previous segment extends to the `M` segment.\n   *\n   * @public\n   */\n  toCurve() {\n    const { segments } = this;\n    this.segments = pathToCurve(segments);\n    return this;\n  }\n\n  /**\n   * Reverse the order of the segments and their values.\n   *\n   * @param onlySubpath option to reverse all sub-paths except first\n   * @public\n   */\n  reverse(onlySubpath?: boolean) {\n    this.toAbsolute();\n\n    const { segments } = this;\n    const split = splitPath(segments);\n    const subPath = split.length > 1 ? split : false;\n\n    const absoluteMultiPath = subPath\n      ? subPath.map((x, i) => {\n          if (onlySubpath) {\n            return i ? reversePath(x) : x.slice(0);\n          }\n          return reversePath(x);\n        })\n      : segments.slice(0);\n\n    let path = [] as unknown as PathArray;\n    if (subPath) {\n      path = absoluteMultiPath.flat(1) as PathArray;\n    } else {\n      path = onlySubpath ? segments : reversePath(segments);\n    }\n\n    this.segments = path.slice(0) as PathArray;\n    return this;\n  }\n\n  /**\n   * Normalize path in 2 steps:\n   * * convert `pathArray`(s) to absolute values\n   * * convert shorthand notation to standard notation\n   *\n   * @public\n   */\n  normalize() {\n    const { segments } = this;\n    this.segments = normalizePath(segments);\n    return this;\n  }\n\n  /**\n   * Optimize `pathArray` values:\n   * * convert segments to absolute and/or relative values\n   * * select segments with shortest resulted string\n   * * round values to the specified `decimals` option value\n   *\n   * @public\n   */\n  optimize() {\n    const { segments } = this;\n\n    this.segments = optimizePath(segments, this.round);\n    return this;\n  }\n\n  /**\n   * Transform path using values from an `Object` defined as `transformObject`.\n   *\n   * @see TransformObject for a quick refference\n   *\n   * @param source a `transformObject`as described above\n   * @public\n   */\n  transform(source?: Partial<TransformObject>) {\n    if (\n      !source ||\n      typeof source !== 'object' ||\n      (typeof source === 'object' && !['translate', 'rotate', 'skew', 'scale'].some(x => x in source))\n    )\n      return this;\n\n    const {\n      segments,\n      origin: [cx, cy, cz],\n    } = this;\n    const transform = {} as TransformObjectValues;\n    for (const [k, v] of Object.entries(source) as TransformEntries) {\n      // istanbul ignore else @preserve\n      if (k === 'skew' && Array.isArray(v)) {\n        transform[k] = v.map(Number) as [number, number];\n      } else if ((k === 'rotate' || k === 'translate' || k === 'origin' || k === 'scale') && Array.isArray(v)) {\n        transform[k] = v.map(Number) as [number, number, number];\n      } else if (k !== 'origin' && typeof Number(v) === 'number') transform[k] = Number(v);\n    }\n\n    // if origin is not specified\n    // it's important that we have one\n    const { origin } = transform;\n\n    if (Array.isArray(origin) && origin.length >= 2) {\n      const [originX, originY, originZ] = origin.map(Number);\n      transform.origin = [!Number.isNaN(originX) ? originX : cx, !Number.isNaN(originY) ? originY : cy, originZ || cz];\n    } else {\n      transform.origin = [cx, cy, cz];\n    }\n\n    this.segments = transformPath(segments, transform);\n    return this;\n  }\n\n  /**\n   * Rotate path 180deg vertically\n   *\n   * @public\n   */\n  flipX() {\n    this.transform({ rotate: [0, 180, 0] });\n    return this;\n  }\n\n  /**\n   * Rotate path 180deg horizontally\n   *\n   * @public\n   */\n  flipY() {\n    this.transform({ rotate: [180, 0, 0] });\n    return this;\n  }\n\n  /**\n   * Export the current path to be used\n   * for the `d` (description) attribute.\n   *\n   * @public\n   * @return the path string\n   */\n  toString() {\n    return pathToString(this.segments, this.round);\n  }\n}\n\nexport default SVGPathCommander;\n"],"names":["defaultOptions","error","paramsCount","finalizeSegment","path","pathCommand","LK","data","scanFlag","index","pathValue","code","isDigit","invalidPathValue","scanParam","max","start","zeroFirst","hasCeiling","hasDecimal","hasDot","ch","isSpace","skipSpaces","isPathCommand","isDigitStart","isArcCommand","isMoveCommand","scanSegment","segments","cmdCode","reqParams","paramCounts","lastSegment","_a","i","PathParser","pathString","isPathArray","seg","lk","parsePathString","pathInput","polygonArea","polygon","n","a","b","area","distanceSquareRoot","polygonLength","length","point","Z","z","s","e","p","$","E","P","y","g","r","l","m","h","c","f","w","o","d","A","M","X","O","x","Y","F","T","k","I","v","R","D","N","isAbsoluteArray","pathToAbsolute","mx","my","segment","values","absCommand","absoluteSegment","absValues","j","normalizeSegment","params","px1","py1","px2","py2","result","x1","y1","qx","qy","nqx","nqy","isNormalizedArray","pc","paramsParser","normalizePath","ii","seglen","midPoint","t","ax","ay","bx","by","getSegmentProperties","x2","y2","distance","min","currentLength","ellipticalArcLength","rx","ry","theta","halfTheta","sinHalfTheta","cosHalfTheta","term1","term2","arcLength","minmax","rotation","startAngle","endAngle","cos","sin","cosRotation","sinRotation","xRotated","yRotated","startX","startY","endX","endY","angleBetween","v0","v1","v0x","v0y","v1x","v1y","RX","RY","angle","LAF","SF","abs","sqrt","PI","xRotRad","getLineSegmentProperties","dx","dy","transformedPoint","radiiCheck","cSquareNumerator","cSquareRootDenom","cRadicand","cCoef","transformedCenter","center","startVector","endVector","sweepAngle","alpha","ellipseComponentX","ellipseComponentY","ZERO","Tvalues","Cvalues","derive","points","dpoints","list","compute","order","mt","mt2","t2","arcfn","derivativeFn","lengthFn","len","sum","curve","idx","step","CBEZIER_MINMAX_EPSILON","minmaxQ","minmaxC","K","S","L","Q","getPointAtCubicSegmentLength","c1x","c1y","c2x","c2y","t1","distanceIsNumber","POINT","getLength","cxMinMax","cyMinMax","getPointAtQuadSegmentLength","cx","cy","DISTANCE_EPSILON","pathFactory","isM","MIN","MAX","LENGTH","props","ll","getArcSegmentProperties","getCubicSegmentProperties","getQuadSegmentProperties","getPathBBox","xMin","yMin","xMax","yMax","width","height","fixArc","allPathCommands","ni","isCurveArray","rotateVector","rad","arcToCubic","X1","Y1","X2","Y2","recursive","d120","res","xy","f1","f2","rx2","ry2","df","f2old","x2old","y2old","c1","s1","c2","s2","hx","hy","m1","m2","m3","m4","newres","quadToCubic","r13","r23","lineToCubic","segmentToCubic","args","px","py","pathToCurve","getCubicSegArea","getPathArea","getTotalLength","getDrawDirection","getPointAtLength","getPropertiesAtLength","pathArray","pathTemp","pathLength","lengthAtSegment","getPropertiesAtPoint","normalPath","distanceTo","precision","scan","closest","scanDistance","bestLength","bestDistance","scanLength","before","after","beforeLength","afterLength","beforeDistance","afterDistance","getClosestPoint","getSegmentOfPoint","getSegmentAtLength","isPointInStroke","isValidPath","isRelativeArray","shapeParams","getLinePath","attr","getPolyPath","getCirclePath","getEllipsePath","getRectanglePath","shapeToPathArray","element","ownerDocument","win","supportedShapes","targetIsElement","tagName","type","shapeAttrs","config","roundPath","roundOption","round","pow","pi","pathToString","shapeToPath","replace","doc","description","name","value","splitPath","composite","getSVGMatrix","transform","matrix","CSSMatrix","origin","originX","originY","translate","rotate","skew","scale","pathToRelative","relativeCommand","relativeSegment","relValues","segLength","shortenSegment","normalSegment","prevCommand","round4","segmentValues","normalValues","optimizePath","absolutePath","relativePath","reverseCurve","rotatedCurve","curveOnly","_","reversePath","isClosed","reversedPath","prevSeg","nextSeg","pLen","translatePoint","cssm","projection2d","point2D","originZ","relativePositionX","relativePositionY","relativePositionZ","replaceArc","normalizedPath","resultedPath","transformPath","jj","lx","ly","transformProps","defaultOrigin","matrixInstance","transformedPath","splitCubic","pts","p0","p1","p2","p3","p4","p5","p6","p7","p8","p9","SVGPathCommander","instanceOptions","undefPath","cz","originOption","pathScale","onlySubpath","split","subPath","absoluteMultiPath","source","__publicField"],"mappings":"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","x_google_ignoreList":[21]}